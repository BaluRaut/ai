// Data Structures Flashcards - Stacks, Queues, Trees, Graphs, Heaps (200 cards)
export const dataStructuresFlashcards = [
  // Arrays & Strings (30 cards)
  { id: 'ds-1', front: 'What is an array?', back: 'Contiguous memory storing elements of same type, O(1) access by index', category: 'arrays', difficulty: 'easy' },
  { id: 'ds-2', front: 'Python list vs array?', back: 'List is dynamic array, can hold mixed types. Array module is typed.', category: 'arrays', difficulty: 'easy' },
  { id: 'ds-3', front: 'Dynamic array resize strategy?', back: 'Double capacity when full - amortized O(1) append', category: 'arrays', difficulty: 'medium' },
  { id: 'ds-4', front: 'Array vs linked list for access?', back: 'Array O(1), Linked list O(n)', category: 'arrays', difficulty: 'easy' },
  { id: 'ds-5', front: 'Array vs linked list for insert?', back: 'Array O(n) shift, Linked list O(1) if at pointer', category: 'arrays', difficulty: 'easy' },
  { id: 'ds-6', front: 'What is string immutability?', back: 'Strings cannot be changed after creation - operations create new strings', category: 'arrays', difficulty: 'easy' },
  { id: 'ds-7', front: 'Why is string concatenation in loop slow?', back: 'Creates new string each time - O(n²). Use join() instead.', category: 'arrays', difficulty: 'medium' },
  { id: 'ds-8', front: '2D array memory layout?', back: 'Row-major (C) or Column-major (Fortran) - affects cache performance', category: 'arrays', difficulty: 'hard' },
  { id: 'ds-9', front: 'Python 2D array gotcha?', back: '`[[0]*n]*m` creates references! Use `[[0]*n for _ in range(m)]`', category: 'arrays', difficulty: 'medium' },
  { id: 'ds-10', front: 'Sparse array representation?', back: 'Dict with indices as keys, or compressed sparse row format', category: 'arrays', difficulty: 'hard' },

  // Linked Lists (35 cards)
  { id: 'ds-11', front: 'What is a linked list?', back: 'Nodes connected by references, not contiguous memory', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-12', front: 'Singly vs doubly linked list?', back: 'Singly: next only. Doubly: next and prev pointers', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-13', front: 'Linked list node structure?', back: 'value + next pointer (+ prev for doubly)', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-14', front: 'Insert at head complexity?', back: 'O(1) - just update head pointer', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-15', front: 'Insert at tail without tail pointer?', back: 'O(n) - must traverse to end', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-16', front: 'Insert at tail with tail pointer?', back: 'O(1) - update tail and its next', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-17', front: 'Delete from singly linked list?', back: 'Need reference to previous node - O(n) to find', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-18', front: 'Delete from doubly linked list?', back: 'O(1) if have node reference - use prev pointer', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-19', front: 'Search in linked list?', back: 'O(n) - must traverse sequentially', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-20', front: 'What is circular linked list?', back: 'Last node points to first, forming a cycle', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-21', front: 'Circular linked list use case?', back: 'Round-robin scheduling, circular buffers', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-22', front: 'Sentinel/dummy node purpose?', back: 'Simplifies edge cases - head/tail never null', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-23', front: 'XOR linked list?', back: 'Stores XOR of prev and next - saves space, tricky to implement', category: 'linkedlist', difficulty: 'hard' },
  { id: 'ds-24', front: 'Skip list?', back: 'Multiple levels of linked lists for O(log n) search', category: 'linkedlist', difficulty: 'hard' },
  { id: 'ds-25', front: 'Linked list vs array memory?', back: 'Linked list uses more (pointer overhead) but no wasted capacity', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-26', front: 'Find middle of linked list?', back: 'Fast/slow pointers - fast moves 2x', category: 'linkedlist', difficulty: 'easy' },
  { id: 'ds-27', front: 'Detect cycle in linked list?', back: 'Fast/slow pointers - if they meet, cycle exists', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-28', front: 'Find cycle start?', back: 'After meeting, reset one to head, both move 1 step', category: 'linkedlist', difficulty: 'hard' },
  { id: 'ds-29', front: 'Reverse linked list iteratively?', back: 'Track prev, curr, next. Redirect curr.next to prev.', category: 'linkedlist', difficulty: 'medium' },
  { id: 'ds-30', front: 'Reverse linked list recursively?', back: 'Recurse to end, set next.next = current, current.next = None', category: 'linkedlist', difficulty: 'medium' },

  // Stacks (25 cards)
  { id: 'ds-31', front: 'What is a stack?', back: 'LIFO (Last In First Out) data structure', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-32', front: 'Stack operations?', back: 'push (add), pop (remove), peek/top (view), isEmpty', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-33', front: 'Stack time complexity?', back: 'All operations O(1)', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-34', front: 'Stack implementation options?', back: 'Array (list) or linked list', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-35', front: 'Python list as stack?', back: 'append() for push, pop() for pop', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-36', front: 'Stack use: function calls?', back: 'Call stack stores return addresses and local variables', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-37', front: 'Stack use: undo operation?', back: 'Push actions, pop to undo', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-38', front: 'Stack use: expression evaluation?', back: 'Operand stack, operator stack with precedence', category: 'stacks', difficulty: 'medium' },
  { id: 'ds-39', front: 'Stack use: parentheses matching?', back: 'Push open brackets, pop and match on close', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-40', front: 'Stack use: browser history?', back: 'Push visited pages, pop for back button', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-41', front: 'What is stack overflow?', back: 'Stack exceeds memory limit - often from infinite recursion', category: 'stacks', difficulty: 'easy' },
  { id: 'ds-42', front: 'Monotonic stack?', back: 'Stack maintaining increasing/decreasing order', category: 'stacks', difficulty: 'hard' },
  { id: 'ds-43', front: 'Monotonic stack use?', back: 'Next greater/smaller element problems', category: 'stacks', difficulty: 'hard' },
  { id: 'ds-44', front: 'Min stack design?', back: 'Auxiliary stack tracking minimum at each level', category: 'stacks', difficulty: 'medium' },
  { id: 'ds-45', front: 'Two stacks in one array?', back: 'Grow from opposite ends', category: 'stacks', difficulty: 'medium' },

  // Queues (25 cards)
  { id: 'ds-46', front: 'What is a queue?', back: 'FIFO (First In First Out) data structure', category: 'queues', difficulty: 'easy' },
  { id: 'ds-47', front: 'Queue operations?', back: 'enqueue (add), dequeue (remove), front/peek, isEmpty', category: 'queues', difficulty: 'easy' },
  { id: 'ds-48', front: 'Queue time complexity?', back: 'All operations O(1) with proper implementation', category: 'queues', difficulty: 'easy' },
  { id: 'ds-49', front: 'Queue with array problem?', back: 'Dequeue causes shift - O(n)', category: 'queues', difficulty: 'medium' },
  { id: 'ds-50', front: 'Circular queue/buffer?', back: 'Wrap around using modulo - avoids shifting', category: 'queues', difficulty: 'medium' },
  { id: 'ds-51', front: 'Python collections.deque?', back: 'Double-ended queue with O(1) operations both ends', category: 'queues', difficulty: 'easy' },
  { id: 'ds-52', front: 'deque.appendleft() vs append()?', back: 'appendleft adds to front, append to back', category: 'queues', difficulty: 'easy' },
  { id: 'ds-53', front: 'Queue use: BFS?', back: 'Level-order traversal of trees/graphs', category: 'queues', difficulty: 'easy' },
  { id: 'ds-54', front: 'Queue use: task scheduling?', back: 'First come first served processing', category: 'queues', difficulty: 'easy' },
  { id: 'ds-55', front: 'Queue use: buffering?', back: 'Handling rate differences between producer/consumer', category: 'queues', difficulty: 'medium' },
  { id: 'ds-56', front: 'What is priority queue?', back: 'Queue where elements have priorities, highest priority first', category: 'queues', difficulty: 'medium' },
  { id: 'ds-57', front: 'Priority queue implementation?', back: 'Usually a heap - O(log n) insert/remove', category: 'queues', difficulty: 'medium' },
  { id: 'ds-58', front: 'Python heapq module?', back: 'Min heap implementation using list', category: 'queues', difficulty: 'medium' },
  { id: 'ds-59', front: 'Double-ended queue (deque)?', back: 'Add/remove from both ends in O(1)', category: 'queues', difficulty: 'easy' },
  { id: 'ds-60', front: 'Implement queue with two stacks?', back: 'In-stack for enqueue, transfer to out-stack for dequeue', category: 'queues', difficulty: 'medium' },

  // Trees (40 cards)
  { id: 'ds-61', front: 'What is a tree?', back: 'Hierarchical structure with nodes and edges, no cycles', category: 'trees', difficulty: 'easy' },
  { id: 'ds-62', front: 'Tree terminology: root?', back: 'Top node with no parent', category: 'trees', difficulty: 'easy' },
  { id: 'ds-63', front: 'Tree terminology: leaf?', back: 'Node with no children', category: 'trees', difficulty: 'easy' },
  { id: 'ds-64', front: 'Tree terminology: height?', back: 'Longest path from root to leaf', category: 'trees', difficulty: 'easy' },
  { id: 'ds-65', front: 'Tree terminology: depth?', back: 'Distance from root to node', category: 'trees', difficulty: 'easy' },
  { id: 'ds-66', front: 'What is binary tree?', back: 'Each node has at most 2 children (left and right)', category: 'trees', difficulty: 'easy' },
  { id: 'ds-67', front: 'Full binary tree?', back: 'Every node has 0 or 2 children', category: 'trees', difficulty: 'easy' },
  { id: 'ds-68', front: 'Complete binary tree?', back: 'All levels full except possibly last, filled left to right', category: 'trees', difficulty: 'medium' },
  { id: 'ds-69', front: 'Perfect binary tree?', back: 'All internal nodes have 2 children, all leaves same level', category: 'trees', difficulty: 'medium' },
  { id: 'ds-70', front: 'Balanced binary tree?', back: 'Height of subtrees differ by at most 1', category: 'trees', difficulty: 'medium' },
  { id: 'ds-71', front: 'Binary search tree (BST)?', back: 'Left subtree < node < right subtree for all nodes', category: 'trees', difficulty: 'easy' },
  { id: 'ds-72', front: 'BST search complexity?', back: 'O(log n) balanced, O(n) worst case (skewed)', category: 'trees', difficulty: 'easy' },
  { id: 'ds-73', front: 'BST insert complexity?', back: 'O(log n) balanced, O(n) worst case', category: 'trees', difficulty: 'easy' },
  { id: 'ds-74', front: 'BST delete cases?', back: '1. Leaf: remove. 2. One child: replace. 3. Two children: replace with successor', category: 'trees', difficulty: 'medium' },
  { id: 'ds-75', front: 'In-order successor?', back: 'Smallest node in right subtree (leftmost)', category: 'trees', difficulty: 'medium' },
  { id: 'ds-76', front: 'Tree traversal: preorder?', back: 'Root → Left → Right', category: 'trees', difficulty: 'easy' },
  { id: 'ds-77', front: 'Tree traversal: inorder?', back: 'Left → Root → Right', category: 'trees', difficulty: 'easy' },
  { id: 'ds-78', front: 'Tree traversal: postorder?', back: 'Left → Right → Root', category: 'trees', difficulty: 'easy' },
  { id: 'ds-79', front: 'Inorder traversal of BST gives?', back: 'Sorted sequence in ascending order', category: 'trees', difficulty: 'easy' },
  { id: 'ds-80', front: 'Level-order traversal uses?', back: 'Queue (BFS approach)', category: 'trees', difficulty: 'easy' },
  { id: 'ds-81', front: 'What is AVL tree?', back: 'Self-balancing BST with height difference ≤ 1', category: 'trees', difficulty: 'hard' },
  { id: 'ds-82', front: 'AVL rotations?', back: 'Single (left/right) and double (left-right/right-left)', category: 'trees', difficulty: 'hard' },
  { id: 'ds-83', front: 'What is Red-Black tree?', back: 'Self-balancing BST with color properties', category: 'trees', difficulty: 'hard' },
  { id: 'ds-84', front: 'Red-Black vs AVL?', back: 'Red-Black: faster insert/delete, AVL: faster lookup', category: 'trees', difficulty: 'hard' },
  { id: 'ds-85', front: 'What is B-tree?', back: 'Self-balancing tree with multiple keys per node, for disk', category: 'trees', difficulty: 'hard' },
  { id: 'ds-86', front: 'What is trie (prefix tree)?', back: 'Tree for storing strings, each edge is character', category: 'trees', difficulty: 'medium' },
  { id: 'ds-87', front: 'Trie search complexity?', back: 'O(m) where m is string length', category: 'trees', difficulty: 'medium' },
  { id: 'ds-88', front: 'Trie use cases?', back: 'Autocomplete, spell check, IP routing', category: 'trees', difficulty: 'medium' },
  { id: 'ds-89', front: 'What is segment tree?', back: 'Tree for range queries and updates', category: 'trees', difficulty: 'hard' },
  { id: 'ds-90', front: 'Segment tree complexity?', back: 'O(log n) query and update', category: 'trees', difficulty: 'hard' },
  { id: 'ds-91', front: 'What is Fenwick/Binary Indexed Tree?', back: 'Efficient prefix sums with O(log n) update/query', category: 'trees', difficulty: 'hard' },
  { id: 'ds-92', front: 'Tree node structure in Python?', back: 'class with val, left, right attributes', category: 'trees', difficulty: 'easy' },
  { id: 'ds-93', front: 'N-ary tree?', back: 'Each node can have any number of children', category: 'trees', difficulty: 'medium' },
  { id: 'ds-94', front: 'Expression tree?', back: 'Binary tree representing mathematical expression', category: 'trees', difficulty: 'medium' },
  { id: 'ds-95', front: 'Huffman tree?', back: 'Binary tree for optimal prefix-free encoding', category: 'trees', difficulty: 'hard' },

  // Heaps (25 cards)
  { id: 'ds-96', front: 'What is a heap?', back: 'Complete binary tree satisfying heap property', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-97', front: 'Min heap property?', back: 'Parent ≤ children (smallest at root)', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-98', front: 'Max heap property?', back: 'Parent ≥ children (largest at root)', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-99', front: 'Heap implementation?', back: 'Usually array - parent at i, children at 2i+1, 2i+2', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-100', front: 'Find parent in array heap?', back: '(i-1) // 2', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-101', front: 'Heap insert (push)?', back: 'Add at end, bubble up - O(log n)', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-102', front: 'Heap extract (pop)?', back: 'Remove root, move last to root, bubble down - O(log n)', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-103', front: 'Heap peek?', back: 'Return root - O(1)', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-104', front: 'Heapify array complexity?', back: 'O(n) not O(n log n)!', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-105', front: 'Why is heapify O(n)?', back: 'Most nodes near leaves, they bubble down less', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-106', front: 'Python heapq is min or max?', back: 'Min heap - use negative values for max heap', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-107', front: 'heapq.heappush()?', back: 'Add element maintaining heap property', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-108', front: 'heapq.heappop()?', back: 'Remove and return smallest element', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-109', front: 'heapq.heapify()?', back: 'Convert list to heap in-place', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-110', front: 'heapq.nlargest(k, iterable)?', back: 'Return k largest elements', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-111', front: 'Heap sort algorithm?', back: 'Build heap, repeatedly extract max', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-112', front: 'Heap sort complexity?', back: 'O(n log n) time, O(1) space', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-113', front: 'Heap use: priority queue?', back: 'Natural implementation - O(log n) operations', category: 'heaps', difficulty: 'easy' },
  { id: 'ds-114', front: 'Heap use: K largest/smallest?', back: 'Maintain heap of size K', category: 'heaps', difficulty: 'medium' },
  { id: 'ds-115', front: 'Heap use: merge K sorted lists?', back: 'Min heap of list heads', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-116', front: 'Heap use: median stream?', back: 'Max heap for lower half, min heap for upper half', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-117', front: 'Heap use: Dijkstra?', back: 'Min heap for next closest vertex', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-118', front: 'D-ary heap?', back: 'Each node has D children instead of 2', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-119', front: 'Fibonacci heap?', back: 'Advanced heap with O(1) amortized insert and decrease-key', category: 'heaps', difficulty: 'hard' },
  { id: 'ds-120', front: 'Binomial heap?', back: 'Mergeable heap with O(log n) merge', category: 'heaps', difficulty: 'hard' },

  // Graphs (45 cards)
  { id: 'ds-121', front: 'What is a graph?', back: 'Set of vertices (nodes) connected by edges', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-122', front: 'Directed vs undirected graph?', back: 'Directed: edges have direction. Undirected: edges are bidirectional', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-123', front: 'Weighted vs unweighted graph?', back: 'Weighted: edges have values. Unweighted: all edges equal', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-124', front: 'Cyclic vs acyclic graph?', back: 'Cyclic: contains cycles. Acyclic: no cycles (DAG if directed)', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-125', front: 'Connected vs disconnected?', back: 'Connected: path between all vertex pairs. Disconnected: isolated components', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-126', front: 'Dense vs sparse graph?', back: 'Dense: edges ≈ V². Sparse: edges ≈ V', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-127', front: 'Adjacency matrix representation?', back: '2D array where matrix[i][j] = 1 if edge exists', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-128', front: 'Adjacency matrix space?', back: 'O(V²)', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-129', front: 'Adjacency list representation?', back: 'Array/dict of lists - each vertex stores its neighbors', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-130', front: 'Adjacency list space?', back: 'O(V + E)', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-131', front: 'When to use matrix vs list?', back: 'Matrix for dense, list for sparse graphs', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-132', front: 'Edge list representation?', back: 'List of (u, v, weight) tuples', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-133', front: 'BFS algorithm?', back: 'Use queue, visit level by level from source', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-134', front: 'BFS complexity?', back: 'O(V + E)', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-135', front: 'BFS use: shortest path?', back: 'Shortest path in unweighted graph', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-136', front: 'DFS algorithm?', back: 'Use stack/recursion, go deep before backtracking', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-137', front: 'DFS complexity?', back: 'O(V + E)', category: 'graphs', difficulty: 'easy' },
  { id: 'ds-138', front: 'DFS use: cycle detection?', back: 'Track visiting vs visited nodes', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-139', front: 'DFS use: topological sort?', back: 'Post-order gives reverse topological order', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-140', front: 'DFS use: connected components?', back: 'Each DFS from unvisited node finds one component', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-141', front: 'Topological sort requirement?', back: 'DAG (Directed Acyclic Graph)', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-142', front: 'Kahn\'s algorithm?', back: 'BFS-based topological sort using indegree', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-143', front: 'Dijkstra\'s algorithm?', back: 'Shortest path from source, greedy with min heap', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-144', front: 'Dijkstra complexity?', back: 'O((V + E) log V) with binary heap', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-145', front: 'Dijkstra limitation?', back: 'Cannot handle negative edge weights', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-146', front: 'Bellman-Ford algorithm?', back: 'Shortest path allowing negative edges, detects negative cycles', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-147', front: 'Bellman-Ford complexity?', back: 'O(V × E)', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-148', front: 'Floyd-Warshall algorithm?', back: 'All-pairs shortest path, O(V³)', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-149', front: 'Minimum Spanning Tree (MST)?', back: 'Tree connecting all vertices with minimum total edge weight', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-150', front: 'Prim\'s algorithm?', back: 'MST by growing tree from vertex, greedy with min heap', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-151', front: 'Kruskal\'s algorithm?', back: 'MST by adding edges in order, use Union-Find', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-152', front: 'Union-Find (Disjoint Set)?', back: 'Track connected components with union and find operations', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-153', front: 'Union-Find path compression?', back: 'Point directly to root - nearly O(1) operations', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-154', front: 'Union by rank?', back: 'Attach smaller tree under larger - keeps tree flat', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-155', front: 'Bipartite graph?', back: 'Can be 2-colored - no odd cycles', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-156', front: 'Check bipartite?', back: 'BFS/DFS 2-coloring - fail if neighbor same color', category: 'graphs', difficulty: 'medium' },
  { id: 'ds-157', front: 'Strongly connected components?', back: 'Maximal subgraphs where every pair is reachable', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-158', front: 'Kosaraju\'s algorithm?', back: 'SCC using two DFS passes', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-159', front: 'Tarjan\'s algorithm?', back: 'SCC in single DFS using low-link values', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-160', front: 'Articulation point?', back: 'Vertex whose removal disconnects graph', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-161', front: 'Bridge edge?', back: 'Edge whose removal disconnects graph', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-162', front: 'Euler path?', back: 'Path visiting every edge exactly once', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-163', front: 'Euler path exists when?', back: 'Exactly 0 or 2 odd-degree vertices', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-164', front: 'Hamiltonian path?', back: 'Path visiting every vertex exactly once (NP-complete)', category: 'graphs', difficulty: 'hard' },
  { id: 'ds-165', front: 'A* algorithm?', back: 'Dijkstra with heuristic for pathfinding', category: 'graphs', difficulty: 'hard' },

  // Hash Tables (35 cards)
  { id: 'ds-166', front: 'What is a hash table?', back: 'Key-value store with O(1) average operations', category: 'hash', difficulty: 'easy' },
  { id: 'ds-167', front: 'Hash function purpose?', back: 'Maps keys to array indices', category: 'hash', difficulty: 'easy' },
  { id: 'ds-168', front: 'Good hash function properties?', back: 'Deterministic, uniform distribution, fast to compute', category: 'hash', difficulty: 'medium' },
  { id: 'ds-169', front: 'What is a collision?', back: 'Two keys hash to same index', category: 'hash', difficulty: 'easy' },
  { id: 'ds-170', front: 'Collision resolution: chaining?', back: 'Each bucket is linked list of entries', category: 'hash', difficulty: 'medium' },
  { id: 'ds-171', front: 'Collision resolution: open addressing?', back: 'Probe for next empty slot', category: 'hash', difficulty: 'medium' },
  { id: 'ds-172', front: 'Linear probing?', back: 'Try slots i, i+1, i+2, ...', category: 'hash', difficulty: 'medium' },
  { id: 'ds-173', front: 'Quadratic probing?', back: 'Try slots i, i+1², i+2², ...', category: 'hash', difficulty: 'medium' },
  { id: 'ds-174', front: 'Double hashing?', back: 'Use second hash function for step size', category: 'hash', difficulty: 'hard' },
  { id: 'ds-175', front: 'What is load factor?', back: 'n/m (items/buckets) - triggers resize when high', category: 'hash', difficulty: 'medium' },
  { id: 'ds-176', front: 'Hash table resize?', back: 'Double size, rehash all keys - amortized O(1)', category: 'hash', difficulty: 'medium' },
  { id: 'ds-177', front: 'Hash table worst case?', back: 'O(n) if all keys collide', category: 'hash', difficulty: 'medium' },
  { id: 'ds-178', front: 'Python dict implementation?', back: 'Open addressing with pseudo-random probing', category: 'hash', difficulty: 'hard' },
  { id: 'ds-179', front: 'Python dict ordering?', back: 'Maintains insertion order (Python 3.7+)', category: 'hash', difficulty: 'medium' },
  { id: 'ds-180', front: 'Python set implementation?', back: 'Hash table without values', category: 'hash', difficulty: 'medium' },
  { id: 'ds-181', front: 'Hashable object requirement?', back: 'Immutable and implements __hash__ and __eq__', category: 'hash', difficulty: 'medium' },
  { id: 'ds-182', front: 'Why can\'t lists be dict keys?', back: 'Mutable - hash would change after modification', category: 'hash', difficulty: 'medium' },
  { id: 'ds-183', front: 'Hash table use: frequency count?', back: 'Key = element, value = count', category: 'hash', difficulty: 'easy' },
  { id: 'ds-184', front: 'Hash table use: caching?', back: 'Key = input, value = result', category: 'hash', difficulty: 'easy' },
  { id: 'ds-185', front: 'Hash table use: deduplication?', back: 'Add to set, duplicates rejected', category: 'hash', difficulty: 'easy' },
  { id: 'ds-186', front: 'Hash table use: indexing?', back: 'Databases, search engines', category: 'hash', difficulty: 'medium' },
  { id: 'ds-187', front: 'Consistent hashing?', back: 'Distributed systems - minimize remapping on resize', category: 'hash', difficulty: 'hard' },
  { id: 'ds-188', front: 'Bloom filter?', back: 'Probabilistic set membership - false positives possible', category: 'hash', difficulty: 'hard' },
  { id: 'ds-189', front: 'Count-Min Sketch?', back: 'Probabilistic frequency counter', category: 'hash', difficulty: 'hard' },
  { id: 'ds-190', front: 'Cuckoo hashing?', back: 'Two hash tables, constant worst-case lookup', category: 'hash', difficulty: 'hard' },
  { id: 'ds-191', front: 'Robin Hood hashing?', back: 'Open addressing minimizing probe length variance', category: 'hash', difficulty: 'hard' },
  { id: 'ds-192', front: 'Perfect hashing?', back: 'No collisions - possible when keys known in advance', category: 'hash', difficulty: 'hard' },
  { id: 'ds-193', front: 'OrderedDict?', back: 'Dict remembering insertion order (less needed in 3.7+)', category: 'hash', difficulty: 'medium' },
  { id: 'ds-194', front: 'defaultdict?', back: 'Dict with default factory for missing keys', category: 'hash', difficulty: 'easy' },
  { id: 'ds-195', front: 'Counter?', back: 'Dict subclass for counting hashable objects', category: 'hash', difficulty: 'easy' },
  { id: 'ds-196', front: 'ChainMap?', back: 'Groups multiple dicts into single view', category: 'hash', difficulty: 'hard' },
  { id: 'ds-197', front: 'Hash collision attack?', back: 'Craft keys causing many collisions - DoS risk', category: 'hash', difficulty: 'hard' },
  { id: 'ds-198', front: 'Python hash randomization?', back: 'Random seed per process to prevent collision attacks', category: 'hash', difficulty: 'hard' },
  { id: 'ds-199', front: 'Two-sum with hash table?', back: 'Store seen values, check if complement exists - O(n)', category: 'hash', difficulty: 'easy' },
  { id: 'ds-200', front: 'Subarray sum equals k?', back: 'Hash map of prefix sums - O(n)', category: 'hash', difficulty: 'medium' }
];

export default dataStructuresFlashcards;
