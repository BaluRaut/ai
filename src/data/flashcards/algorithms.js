// Algorithms Flashcards - Sorting, Searching, Complexity (200 cards)
export const algorithmsFlashcards = [
  // Big O Notation (40 cards)
  { id: 'alg-1', front: 'What is Big O notation?', back: 'Describes upper bound of algorithm\'s time/space complexity as input grows', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-2', front: 'What is O(1)?', back: 'Constant time - same time regardless of input size', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-3', front: 'What is O(n)?', back: 'Linear time - time grows proportionally with input size', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-4', front: 'What is O(n²)?', back: 'Quadratic time - nested loops over input', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-5', front: 'What is O(log n)?', back: 'Logarithmic time - halving input each step (binary search)', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-6', front: 'What is O(n log n)?', back: 'Linearithmic - efficient sorting algorithms', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-7', front: 'What is O(2ⁿ)?', back: 'Exponential time - doubles with each additional element', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-8', front: 'What is O(n!)?', back: 'Factorial time - permutations, worst complexity', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-9', front: 'Order these: O(n), O(1), O(n²), O(log n)', back: 'O(1) < O(log n) < O(n) < O(n²)', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-10', front: 'What is time complexity?', back: 'How runtime grows with input size', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-11', front: 'What is space complexity?', back: 'How memory usage grows with input size', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-12', front: 'What is best case complexity?', back: 'Minimum time/space for optimal input', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-13', front: 'What is worst case complexity?', back: 'Maximum time/space for worst possible input', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-14', front: 'What is average case complexity?', back: 'Expected time/space over all inputs', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-15', front: 'What is amortized complexity?', back: 'Average per operation over worst-case sequence', category: 'complexity', difficulty: 'hard' },
  { id: 'alg-16', front: 'Time complexity of list append?', back: 'O(1) amortized - occasional O(n) for resize', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-17', front: 'Time complexity of list insert at beginning?', back: 'O(n) - must shift all elements', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-18', front: 'Time complexity of dict lookup?', back: 'O(1) average, O(n) worst case', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-19', front: 'Time complexity of set membership?', back: 'O(1) average - hash table', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-20', front: 'Time complexity of list membership?', back: 'O(n) - must check each element', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-21', front: 'Time complexity of accessing list by index?', back: 'O(1) - direct memory access', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-22', front: 'Time complexity of slicing list[a:b]?', back: 'O(b-a) or O(k) - creates copy of k elements', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-23', front: 'What is auxiliary space?', back: 'Extra space beyond input storage', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-24', front: 'What is in-place algorithm?', back: 'Uses O(1) auxiliary space', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-25', front: 'What is Big Omega (Ω)?', back: 'Lower bound - best case notation', category: 'complexity', difficulty: 'hard' },
  { id: 'alg-26', front: 'What is Big Theta (Θ)?', back: 'Tight bound - exact growth rate', category: 'complexity', difficulty: 'hard' },
  { id: 'alg-27', front: 'Why do we drop constants in Big O?', back: 'Focus on growth rate, not absolute time', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-28', front: 'Why drop lower order terms?', back: 'Highest order dominates as n→∞', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-29', front: 'O(2n) simplifies to?', back: 'O(n) - drop constant coefficient', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-30', front: 'O(n² + n) simplifies to?', back: 'O(n²) - drop lower order term', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-31', front: 'Complexity of two nested loops over n?', back: 'O(n²)', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-32', front: 'Complexity of three nested loops over n?', back: 'O(n³)', category: 'complexity', difficulty: 'easy' },
  { id: 'alg-33', front: 'Complexity of loop halving n each time?', back: 'O(log n)', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-34', front: 'Complexity of loop with n * loop halving?', back: 'O(n log n)', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-35', front: 'Complexity of recursive calls with 2 branches, n depth?', back: 'O(2ⁿ)', category: 'complexity', difficulty: 'hard' },
  { id: 'alg-36', front: 'What is Master Theorem?', back: 'Solves recurrence relations for divide-and-conquer', category: 'complexity', difficulty: 'hard' },
  { id: 'alg-37', front: 'Time complexity of string concatenation in loop?', back: 'O(n²) - creates new string each time. Use join()!', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-38', front: 'Space complexity of recursive factorial?', back: 'O(n) - call stack depth', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-39', front: 'Space complexity of iterative factorial?', back: 'O(1) - constant extra space', category: 'complexity', difficulty: 'medium' },
  { id: 'alg-40', front: 'What makes algorithm efficient?', back: 'Low time and space complexity for expected inputs', category: 'complexity', difficulty: 'easy' },

  // Sorting Algorithms (60 cards)
  { id: 'alg-41', front: 'What is Bubble Sort?', back: 'Repeatedly swap adjacent elements if in wrong order', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-42', front: 'Bubble Sort time complexity?', back: 'O(n²) average/worst, O(n) best (already sorted)', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-43', front: 'Bubble Sort space complexity?', back: 'O(1) - in-place', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-44', front: 'Is Bubble Sort stable?', back: 'Yes - equal elements maintain relative order', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-45', front: 'What is Selection Sort?', back: 'Find minimum, swap to front, repeat for remaining', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-46', front: 'Selection Sort time complexity?', back: 'O(n²) all cases', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-47', front: 'Is Selection Sort stable?', back: 'No - can change relative order of equal elements', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-48', front: 'What is Insertion Sort?', back: 'Build sorted portion by inserting each element in correct position', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-49', front: 'Insertion Sort time complexity?', back: 'O(n²) average/worst, O(n) best', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-50', front: 'When is Insertion Sort good?', back: 'Small arrays or nearly sorted data', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-51', front: 'Is Insertion Sort stable?', back: 'Yes', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-52', front: 'What is Merge Sort?', back: 'Divide array in half, recursively sort, merge halves', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-53', front: 'Merge Sort time complexity?', back: 'O(n log n) all cases', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-54', front: 'Merge Sort space complexity?', back: 'O(n) - needs extra array for merging', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-55', front: 'Is Merge Sort stable?', back: 'Yes', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-56', front: 'What is Quick Sort?', back: 'Choose pivot, partition around it, recursively sort partitions', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-57', front: 'Quick Sort time complexity?', back: 'O(n log n) average, O(n²) worst', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-58', front: 'When is Quick Sort worst case?', back: 'Already sorted and bad pivot choice (first/last element)', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-59', front: 'How to avoid Quick Sort worst case?', back: 'Random pivot, median-of-three, or hybrid approach', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-60', front: 'Quick Sort space complexity?', back: 'O(log n) average for recursion, O(n) worst', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-61', front: 'Is Quick Sort stable?', back: 'No (standard implementation)', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-62', front: 'Why is Quick Sort often faster than Merge Sort?', back: 'Better cache performance, in-place, smaller constant factors', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-63', front: 'What is Heap Sort?', back: 'Build max heap, repeatedly extract max', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-64', front: 'Heap Sort time complexity?', back: 'O(n log n) all cases', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-65', front: 'Heap Sort space complexity?', back: 'O(1) - in-place', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-66', front: 'Is Heap Sort stable?', back: 'No', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-67', front: 'What is Counting Sort?', back: 'Count occurrences, calculate positions, place elements', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-68', front: 'Counting Sort time complexity?', back: 'O(n + k) where k is range of values', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-69', front: 'When to use Counting Sort?', back: 'Integer keys with small range', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-70', front: 'What is Radix Sort?', back: 'Sort by each digit, least to most significant', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-71', front: 'Radix Sort time complexity?', back: 'O(d × (n + k)) where d is digits, k is base', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-72', front: 'What is Bucket Sort?', back: 'Distribute to buckets, sort each bucket, concatenate', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-73', front: 'Bucket Sort time complexity?', back: 'O(n + k) average if uniform distribution', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-74', front: 'What is TimSort?', back: 'Hybrid of merge sort and insertion sort - Python\'s default', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-75', front: 'TimSort time complexity?', back: 'O(n log n) worst, O(n) best', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-76', front: 'What is stable sorting?', back: 'Equal elements maintain their relative order', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-77', front: 'Which Python sorts are stable?', back: '`sorted()` and `list.sort()` - both use TimSort', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-78', front: 'How to sort by multiple keys?', back: 'Sort by secondary first, then primary (stable sort property)', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-79', front: 'What is comparison-based sorting?', back: 'Sorts only by comparing pairs of elements', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-80', front: 'Lower bound for comparison sorts?', back: 'O(n log n) - proven mathematical limit', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-81', front: 'How to sort dict by value?', back: '`sorted(d.items(), key=lambda x: x[1])`', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-82', front: 'How to sort objects by attribute?', back: '`sorted(objects, key=lambda x: x.attr)` or `attrgetter`', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-83', front: 'What is `operator.itemgetter`?', back: 'Faster key function: `sorted(list, key=itemgetter(1))`', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-84', front: 'What is `operator.attrgetter`?', back: 'Key function for attributes: `sorted(objs, key=attrgetter("name"))`', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-85', front: 'How to reverse sort?', back: '`sorted(list, reverse=True)`', category: 'sorting', difficulty: 'easy' },
  { id: 'alg-86', front: 'What is partial sorting?', back: 'Finding k smallest/largest without full sort', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-87', front: 'How to get k smallest in Python?', back: '`heapq.nsmallest(k, list)` - O(n log k)', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-88', front: 'How to get k largest in Python?', back: '`heapq.nlargest(k, list)` - O(n log k)', category: 'sorting', difficulty: 'medium' },
  { id: 'alg-89', front: 'What is Quickselect?', back: 'Find kth smallest in O(n) average - like Quick Sort partition', category: 'sorting', difficulty: 'hard' },
  { id: 'alg-90', front: 'When to use which sorting algorithm?', back: 'Small: insertion, general: quicksort/timsort, stable: mergesort', category: 'sorting', difficulty: 'medium' },

  // Searching Algorithms (50 cards)
  { id: 'alg-91', front: 'What is Linear Search?', back: 'Check each element until found', category: 'searching', difficulty: 'easy' },
  { id: 'alg-92', front: 'Linear Search time complexity?', back: 'O(n)', category: 'searching', difficulty: 'easy' },
  { id: 'alg-93', front: 'When to use Linear Search?', back: 'Unsorted data, small arrays, single search', category: 'searching', difficulty: 'easy' },
  { id: 'alg-94', front: 'What is Binary Search?', back: 'Halve search space by comparing to middle element', category: 'searching', difficulty: 'easy' },
  { id: 'alg-95', front: 'Binary Search time complexity?', back: 'O(log n)', category: 'searching', difficulty: 'easy' },
  { id: 'alg-96', front: 'Binary Search requirement?', back: 'Array must be sorted', category: 'searching', difficulty: 'easy' },
  { id: 'alg-97', front: 'Binary Search space complexity?', back: 'O(1) iterative, O(log n) recursive', category: 'searching', difficulty: 'medium' },
  { id: 'alg-98', front: 'How to find insertion point in sorted list?', back: '`bisect.bisect_left(list, x)`', category: 'searching', difficulty: 'medium' },
  { id: 'alg-99', front: 'Difference between bisect_left and bisect_right?', back: 'Left: before equal elements, Right: after equal elements', category: 'searching', difficulty: 'medium' },
  { id: 'alg-100', front: 'How to insert in sorted list?', back: '`bisect.insort(list, x)`', category: 'searching', difficulty: 'medium' },
  { id: 'alg-101', front: 'What is Interpolation Search?', back: 'Like binary search but estimates position based on value', category: 'searching', difficulty: 'hard' },
  { id: 'alg-102', front: 'When is Interpolation Search best?', back: 'Uniformly distributed sorted data', category: 'searching', difficulty: 'hard' },
  { id: 'alg-103', front: 'What is Jump Search?', back: 'Jump ahead by √n, then linear search backwards', category: 'searching', difficulty: 'hard' },
  { id: 'alg-104', front: 'Jump Search time complexity?', back: 'O(√n)', category: 'searching', difficulty: 'hard' },
  { id: 'alg-105', front: 'What is Exponential Search?', back: 'Find range with exponential jumps, then binary search', category: 'searching', difficulty: 'hard' },
  { id: 'alg-106', front: 'Exponential Search use case?', back: 'Unbounded/infinite arrays', category: 'searching', difficulty: 'hard' },
  { id: 'alg-107', front: 'What is Ternary Search?', back: 'Divide into thirds - for finding max/min in unimodal function', category: 'searching', difficulty: 'hard' },
  { id: 'alg-108', front: 'How to find first occurrence in sorted array?', back: 'Binary search, continue left when found', category: 'searching', difficulty: 'medium' },
  { id: 'alg-109', front: 'How to find last occurrence in sorted array?', back: 'Binary search, continue right when found', category: 'searching', difficulty: 'medium' },
  { id: 'alg-110', front: 'How to count occurrences in sorted array?', back: 'Find first and last, subtract indices', category: 'searching', difficulty: 'medium' },
  { id: 'alg-111', front: 'How to find rotation point in rotated sorted array?', back: 'Modified binary search - find where arr[mid] > arr[mid+1]', category: 'searching', difficulty: 'hard' },
  { id: 'alg-112', front: 'How to search in rotated sorted array?', back: 'Find pivot, binary search appropriate half', category: 'searching', difficulty: 'hard' },
  { id: 'alg-113', front: 'What is peak element?', back: 'Element greater than neighbors', category: 'searching', difficulty: 'medium' },
  { id: 'alg-114', front: 'How to find peak in O(log n)?', back: 'Binary search - go towards larger neighbor', category: 'searching', difficulty: 'medium' },
  { id: 'alg-115', front: 'How to find square root using binary search?', back: 'Search for largest x where x² ≤ n', category: 'searching', difficulty: 'medium' },
  { id: 'alg-116', front: 'Binary search on answer technique?', back: 'When answer is bounded and can verify in O(n)', category: 'searching', difficulty: 'hard' },
  { id: 'alg-117', front: 'How to find kth smallest in matrix?', back: 'Binary search on value range, count elements ≤ mid', category: 'searching', difficulty: 'hard' },
  { id: 'alg-118', front: 'What is hash-based search?', back: 'O(1) lookup using dict/set', category: 'searching', difficulty: 'easy' },
  { id: 'alg-119', front: 'Trade-off of hash vs binary search?', back: 'Hash: O(1) but O(n) space. Binary: O(log n) no extra space', category: 'searching', difficulty: 'medium' },
  { id: 'alg-120', front: 'How to find two numbers that sum to target?', back: 'Use set: for each x, check if target-x exists', category: 'searching', difficulty: 'medium' },

  // Recursion & Dynamic Programming (50 cards)
  { id: 'alg-121', front: 'What is recursion?', back: 'Function calling itself with smaller input', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-122', front: 'What is base case?', back: 'Condition that stops recursion', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-123', front: 'What is recursive case?', back: 'When function calls itself with modified input', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-124', front: 'What happens without base case?', back: 'Stack overflow - infinite recursion', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-125', front: 'Recursive factorial formula?', back: 'n! = n × (n-1)!, base: 0! = 1', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-126', front: 'Recursive Fibonacci formula?', back: 'F(n) = F(n-1) + F(n-2), base: F(0)=0, F(1)=1', category: 'recursion', difficulty: 'easy' },
  { id: 'alg-127', front: 'Why is naive Fibonacci O(2ⁿ)?', back: 'Each call makes 2 calls, repeated subproblems', category: 'recursion', difficulty: 'medium' },
  { id: 'alg-128', front: 'What is tail recursion?', back: 'Recursive call is last operation - can be optimized', category: 'recursion', difficulty: 'hard' },
  { id: 'alg-129', front: 'Does Python optimize tail recursion?', back: 'No - still creates new stack frame', category: 'recursion', difficulty: 'hard' },
  { id: 'alg-130', front: 'How to convert recursion to iteration?', back: 'Use explicit stack or accumulator pattern', category: 'recursion', difficulty: 'medium' },
  { id: 'alg-131', front: 'What is Dynamic Programming (DP)?', back: 'Solve problems by breaking into overlapping subproblems', category: 'dp', difficulty: 'medium' },
  { id: 'alg-132', front: 'Two properties for DP?', back: 'Optimal substructure + overlapping subproblems', category: 'dp', difficulty: 'medium' },
  { id: 'alg-133', front: 'What is optimal substructure?', back: 'Optimal solution contains optimal solutions to subproblems', category: 'dp', difficulty: 'medium' },
  { id: 'alg-134', front: 'What is overlapping subproblems?', back: 'Same subproblems solved multiple times', category: 'dp', difficulty: 'medium' },
  { id: 'alg-135', front: 'What is memoization?', back: 'Top-down DP - cache results of subproblems', category: 'dp', difficulty: 'medium' },
  { id: 'alg-136', front: 'What is tabulation?', back: 'Bottom-up DP - fill table from base cases', category: 'dp', difficulty: 'medium' },
  { id: 'alg-137', front: 'Memoization vs Tabulation?', back: 'Memoization: top-down, recursive. Tabulation: bottom-up, iterative', category: 'dp', difficulty: 'medium' },
  { id: 'alg-138', front: 'How to memoize in Python?', back: 'Dict cache or `@functools.lru_cache`', category: 'dp', difficulty: 'medium' },
  { id: 'alg-139', front: 'Fibonacci with memoization complexity?', back: 'O(n) time, O(n) space', category: 'dp', difficulty: 'medium' },
  { id: 'alg-140', front: 'Fibonacci with tabulation complexity?', back: 'O(n) time, O(n) space (can be O(1) space)', category: 'dp', difficulty: 'medium' },
  { id: 'alg-141', front: 'What is the Climbing Stairs problem?', back: 'Count ways to climb n steps, 1 or 2 at a time', category: 'dp', difficulty: 'easy' },
  { id: 'alg-142', front: 'Climbing Stairs recurrence?', back: 'ways(n) = ways(n-1) + ways(n-2)', category: 'dp', difficulty: 'easy' },
  { id: 'alg-143', front: 'What is the Coin Change problem?', back: 'Minimum coins to make amount', category: 'dp', difficulty: 'medium' },
  { id: 'alg-144', front: 'Coin Change recurrence?', back: 'dp[i] = min(dp[i], 1 + dp[i - coin]) for each coin', category: 'dp', difficulty: 'medium' },
  { id: 'alg-145', front: 'What is 0/1 Knapsack?', back: 'Maximize value with weight limit, each item once', category: 'dp', difficulty: 'hard' },
  { id: 'alg-146', front: 'Knapsack recurrence?', back: 'dp[i][w] = max(dp[i-1][w], val[i] + dp[i-1][w-wt[i]])', category: 'dp', difficulty: 'hard' },
  { id: 'alg-147', front: 'What is Longest Common Subsequence (LCS)?', back: 'Longest subsequence common to both strings', category: 'dp', difficulty: 'hard' },
  { id: 'alg-148', front: 'LCS recurrence?', back: 'If match: 1 + dp[i-1][j-1], else: max(dp[i-1][j], dp[i][j-1])', category: 'dp', difficulty: 'hard' },
  { id: 'alg-149', front: 'What is Longest Increasing Subsequence (LIS)?', back: 'Longest subsequence in increasing order', category: 'dp', difficulty: 'hard' },
  { id: 'alg-150', front: 'LIS time complexity?', back: 'O(n²) basic DP, O(n log n) with binary search', category: 'dp', difficulty: 'hard' },
  { id: 'alg-151', front: 'What is Edit Distance?', back: 'Minimum operations to transform one string to another', category: 'dp', difficulty: 'hard' },
  { id: 'alg-152', front: 'Edit Distance operations?', back: 'Insert, Delete, Replace', category: 'dp', difficulty: 'hard' },
  { id: 'alg-153', front: 'What is Maximum Subarray (Kadane\'s)?', back: 'Find contiguous subarray with maximum sum', category: 'dp', difficulty: 'medium' },
  { id: 'alg-154', front: 'Kadane\'s algorithm idea?', back: 'max_ending_here = max(num, max_ending_here + num)', category: 'dp', difficulty: 'medium' },
  { id: 'alg-155', front: 'What is House Robber problem?', back: 'Max sum of non-adjacent elements', category: 'dp', difficulty: 'medium' },
  { id: 'alg-156', front: 'House Robber recurrence?', back: 'dp[i] = max(dp[i-1], nums[i] + dp[i-2])', category: 'dp', difficulty: 'medium' },
  { id: 'alg-157', front: 'What is Word Break problem?', back: 'Can string be segmented into dictionary words?', category: 'dp', difficulty: 'hard' },
  { id: 'alg-158', front: 'What is Matrix Chain Multiplication?', back: 'Optimal order to multiply matrices', category: 'dp', difficulty: 'hard' },
  { id: 'alg-159', front: 'What is state in DP?', back: 'Variables that define a subproblem', category: 'dp', difficulty: 'medium' },
  { id: 'alg-160', front: 'How to identify DP problem?', back: 'Count ways, min/max, yes/no with overlapping subproblems', category: 'dp', difficulty: 'medium' },

  // Data Structures Complexity (40 cards)
  { id: 'alg-161', front: 'Array access by index complexity?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-162', front: 'Array insert at end complexity?', back: 'O(1) amortized', category: 'ds', difficulty: 'easy' },
  { id: 'alg-163', front: 'Array insert at beginning complexity?', back: 'O(n) - must shift elements', category: 'ds', difficulty: 'easy' },
  { id: 'alg-164', front: 'Array delete from middle complexity?', back: 'O(n) - must shift elements', category: 'ds', difficulty: 'easy' },
  { id: 'alg-165', front: 'Linked list access by index complexity?', back: 'O(n) - must traverse', category: 'ds', difficulty: 'easy' },
  { id: 'alg-166', front: 'Linked list insert at head complexity?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-167', front: 'Linked list insert at tail (with pointer)?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-168', front: 'Stack push/pop complexity?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-169', front: 'Queue enqueue/dequeue complexity?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-170', front: 'Binary Search Tree search complexity?', back: 'O(log n) average, O(n) worst (unbalanced)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-171', front: 'BST insert complexity?', back: 'O(log n) average, O(n) worst', category: 'ds', difficulty: 'medium' },
  { id: 'alg-172', front: 'Balanced BST (AVL, Red-Black) search?', back: 'O(log n) guaranteed', category: 'ds', difficulty: 'medium' },
  { id: 'alg-173', front: 'Hash table insert/lookup average?', back: 'O(1)', category: 'ds', difficulty: 'easy' },
  { id: 'alg-174', front: 'Hash table worst case?', back: 'O(n) - all elements collide', category: 'ds', difficulty: 'medium' },
  { id: 'alg-175', front: 'Heap insert complexity?', back: 'O(log n)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-176', front: 'Heap extract-min complexity?', back: 'O(log n)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-177', front: 'Heap get-min complexity?', back: 'O(1) - always at root', category: 'ds', difficulty: 'medium' },
  { id: 'alg-178', front: 'Heapify array complexity?', back: 'O(n) - not O(n log n)!', category: 'ds', difficulty: 'hard' },
  { id: 'alg-179', front: 'Trie insert complexity?', back: 'O(m) where m is key length', category: 'ds', difficulty: 'hard' },
  { id: 'alg-180', front: 'Trie search complexity?', back: 'O(m) where m is key length', category: 'ds', difficulty: 'hard' },
  { id: 'alg-181', front: 'Graph BFS/DFS complexity?', back: 'O(V + E)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-182', front: 'Dijkstra with binary heap?', back: 'O((V + E) log V)', category: 'ds', difficulty: 'hard' },
  { id: 'alg-183', front: 'Floyd-Warshall complexity?', back: 'O(V³) - all pairs shortest path', category: 'ds', difficulty: 'hard' },
  { id: 'alg-184', front: 'Union-Find with optimizations?', back: 'O(α(n)) ≈ O(1) per operation', category: 'ds', difficulty: 'hard' },
  { id: 'alg-185', front: 'Segment Tree query/update?', back: 'O(log n)', category: 'ds', difficulty: 'hard' },
  { id: 'alg-186', front: 'Fenwick Tree query/update?', back: 'O(log n)', category: 'ds', difficulty: 'hard' },
  { id: 'alg-187', front: 'What is space-time tradeoff?', back: 'Using more memory to reduce time or vice versa', category: 'ds', difficulty: 'medium' },
  { id: 'alg-188', front: 'Example of space-time tradeoff?', back: 'Hash table (more space) vs binary search (less space)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-189', front: 'What is cache efficiency?', back: 'How well algorithm uses CPU cache for faster access', category: 'ds', difficulty: 'hard' },
  { id: 'alg-190', front: 'Why are arrays cache-friendly?', back: 'Contiguous memory - prefetching works well', category: 'ds', difficulty: 'hard' },
  { id: 'alg-191', front: 'Why are linked lists cache-unfriendly?', back: 'Scattered memory - cache misses', category: 'ds', difficulty: 'hard' },
  { id: 'alg-192', front: 'What is locality of reference?', back: 'Tendency to access same or nearby locations', category: 'ds', difficulty: 'hard' },
  { id: 'alg-193', front: 'Temporal locality?', back: 'Recently accessed data likely to be accessed again', category: 'ds', difficulty: 'hard' },
  { id: 'alg-194', front: 'Spatial locality?', back: 'Nearby data likely to be accessed together', category: 'ds', difficulty: 'hard' },
  { id: 'alg-195', front: 'Python list implementation?', back: 'Dynamic array - contiguous memory', category: 'ds', difficulty: 'medium' },
  { id: 'alg-196', front: 'Python dict implementation?', back: 'Hash table with open addressing', category: 'ds', difficulty: 'medium' },
  { id: 'alg-197', front: 'Why is dict ordering preserved in Python 3.7+?', back: 'Implementation detail became language feature', category: 'ds', difficulty: 'medium' },
  { id: 'alg-198', front: 'Python set implementation?', back: 'Hash table (like dict without values)', category: 'ds', difficulty: 'medium' },
  { id: 'alg-199', front: 'deque implementation?', back: 'Doubly-linked list of blocks', category: 'ds', difficulty: 'medium' },
  { id: 'alg-200', front: 'heapq implementation?', back: 'Binary heap using list', category: 'ds', difficulty: 'medium' }
];

export default algorithmsFlashcards;
