// Interview Concepts Flashcards - Common interview topics (200 cards)
export const interviewFlashcards = [
  // Two Pointers & Sliding Window (40 cards)
  { id: 'int-1', front: 'What is two pointers technique?', back: 'Using two indices to traverse data structure, often from opposite ends', category: 'techniques', difficulty: 'medium' },
  { id: 'int-2', front: 'When to use two pointers?', back: 'Sorted arrays, finding pairs, palindromes, container problems', category: 'techniques', difficulty: 'medium' },
  { id: 'int-3', front: 'Two pointers for Two Sum (sorted)?', back: 'Left at start, right at end. Sum too small: left++. Sum too big: right--', category: 'techniques', difficulty: 'medium' },
  { id: 'int-4', front: 'Time complexity of two pointers?', back: 'Usually O(n) - each pointer moves at most n times', category: 'techniques', difficulty: 'medium' },
  { id: 'int-5', front: 'Palindrome check with two pointers?', back: 'Compare chars from both ends moving inward', category: 'techniques', difficulty: 'easy' },
  { id: 'int-6', front: 'Container with most water approach?', back: 'Two pointers from ends, move shorter line inward', category: 'techniques', difficulty: 'hard' },
  { id: 'int-7', front: 'What is sliding window?', back: 'Window of fixed/variable size that slides through data', category: 'techniques', difficulty: 'medium' },
  { id: 'int-8', front: 'When to use sliding window?', back: 'Subarray/substring problems, max/min in window, averages', category: 'techniques', difficulty: 'medium' },
  { id: 'int-9', front: 'Fixed vs variable window?', back: 'Fixed: size stays same. Variable: expands/contracts based on condition', category: 'techniques', difficulty: 'medium' },
  { id: 'int-10', front: 'Max sum subarray of size k?', back: 'Sliding window: add new, subtract old, track max', category: 'techniques', difficulty: 'medium' },
  { id: 'int-11', front: 'Sliding window time complexity?', back: 'O(n) - each element added/removed once', category: 'techniques', difficulty: 'medium' },
  { id: 'int-12', front: 'Longest substring without repeating?', back: 'Variable window + hash set, shrink on duplicate', category: 'techniques', difficulty: 'hard' },
  { id: 'int-13', front: 'Minimum window substring?', back: 'Expand to include all chars, shrink to minimize', category: 'techniques', difficulty: 'hard' },
  { id: 'int-14', front: 'Three pointer technique?', back: 'Extension of two pointers, often for 3Sum type problems', category: 'techniques', difficulty: 'hard' },
  { id: 'int-15', front: '3Sum approach?', back: 'Sort, fix one element, two pointers for remaining pair', category: 'techniques', difficulty: 'hard' },
  { id: 'int-16', front: 'Fast and slow pointers?', back: 'Two pointers moving at different speeds (tortoise and hare)', category: 'techniques', difficulty: 'medium' },
  { id: 'int-17', front: 'Detect cycle with fast/slow pointers?', back: 'Fast moves 2x, slow moves 1x. If they meet, cycle exists', category: 'techniques', difficulty: 'medium' },
  { id: 'int-18', front: 'Find cycle start?', back: 'After meeting, reset one to start, both move 1x until meet', category: 'techniques', difficulty: 'hard' },
  { id: 'int-19', front: 'Find middle of linked list?', back: 'Slow moves 1, fast moves 2. When fast ends, slow is middle', category: 'techniques', difficulty: 'medium' },
  { id: 'int-20', front: 'Remove duplicates from sorted array?', back: 'Two pointers: read and write positions', category: 'techniques', difficulty: 'medium' },

  // Hash Maps (30 cards)
  { id: 'int-21', front: 'Why use hash map in interviews?', back: 'O(1) lookup transforms O(n²) to O(n) solutions', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-22', front: 'Two Sum with hash map?', back: 'Store num→index. For each x, check if target-x exists', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-23', front: 'Count frequency with hash map?', back: '`Counter(list)` or `d[x] = d.get(x, 0) + 1`', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-24', front: 'Check anagrams with hash map?', back: 'Compare character frequencies of both strings', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-25', front: 'Group anagrams approach?', back: 'Sort each word as key, group by key in dict', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-26', front: 'First non-repeating character?', back: 'Count frequencies, find first with count 1', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-27', front: 'Subarray sum equals k?', back: 'Prefix sum + hash map of prefix sum frequencies', category: 'hashmap', difficulty: 'hard' },
  { id: 'int-28', front: 'What is prefix sum?', back: 'Running sum: prefix[i] = sum of elements 0 to i', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-29', front: 'Subarray sum with prefix?', back: 'sum(i,j) = prefix[j] - prefix[i-1]', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-30', front: 'LRU Cache data structure?', back: 'Hash map + doubly linked list for O(1) operations', category: 'hashmap', difficulty: 'hard' },
  { id: 'int-31', front: 'Python OrderedDict for LRU?', back: 'Move to end on access, popitem(last=False) to evict', category: 'hashmap', difficulty: 'hard' },
  { id: 'int-32', front: 'Find duplicates with hash set?', back: 'Add to set, if already present it\'s duplicate', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-33', front: 'Intersection of two arrays?', back: 'Convert one to set, check other against it', category: 'hashmap', difficulty: 'easy' },
  { id: 'int-34', front: 'Longest consecutive sequence?', back: 'Set for O(1) lookup, find sequence starts, count forward', category: 'hashmap', difficulty: 'hard' },
  { id: 'int-35', front: 'Valid sudoku check?', back: 'Hash sets for each row, column, and 3x3 box', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-36', front: 'Top K frequent elements?', back: 'Counter + heap or bucket sort', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-37', front: 'Word pattern matching?', back: 'Two hash maps: pattern→word and word→pattern', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-38', front: 'Isomorphic strings?', back: 'Bijection check: two hash maps for mapping both ways', category: 'hashmap', difficulty: 'medium' },
  { id: 'int-39', front: 'Four sum count?', back: 'Pair sums in hash map, find complement pairs', category: 'hashmap', difficulty: 'hard' },
  { id: 'int-40', front: 'Majority element?', back: 'Boyer-Moore voting or hash map counting', category: 'hashmap', difficulty: 'medium' },

  // Stack & Queue (30 cards)
  { id: 'int-41', front: 'Valid parentheses approach?', back: 'Stack: push open, pop on close, check match', category: 'stack', difficulty: 'easy' },
  { id: 'int-42', front: 'Stack for expression evaluation?', back: 'Operand stack and operator stack with precedence', category: 'stack', difficulty: 'hard' },
  { id: 'int-43', front: 'What is monotonic stack?', back: 'Stack maintaining increasing/decreasing order', category: 'stack', difficulty: 'hard' },
  { id: 'int-44', front: 'Next greater element?', back: 'Monotonic decreasing stack, pop smaller, record', category: 'stack', difficulty: 'hard' },
  { id: 'int-45', front: 'Daily temperatures problem?', back: 'Monotonic stack of indices, calculate distances', category: 'stack', difficulty: 'hard' },
  { id: 'int-46', front: 'Largest rectangle in histogram?', back: 'Monotonic stack to find left/right boundaries', category: 'stack', difficulty: 'hard' },
  { id: 'int-47', front: 'Min stack implementation?', back: 'Two stacks: one for values, one for minimums', category: 'stack', difficulty: 'medium' },
  { id: 'int-48', front: 'Implement queue using stacks?', back: 'Two stacks: in-stack and out-stack, amortized O(1)', category: 'stack', difficulty: 'medium' },
  { id: 'int-49', front: 'Implement stack using queues?', back: 'Push: add to queue, pop all but last to back', category: 'stack', difficulty: 'medium' },
  { id: 'int-50', front: 'Evaluate RPN (Reverse Polish)?', back: 'Stack: push numbers, pop two on operator, push result', category: 'stack', difficulty: 'medium' },
  { id: 'int-51', front: 'Simplify path (Unix)?', back: 'Stack: push dirs, pop on "..", skip ".", join at end', category: 'stack', difficulty: 'medium' },
  { id: 'int-52', front: 'Decode string "[3[a]]"?', back: 'Stack to handle nested brackets, multiply on close', category: 'stack', difficulty: 'medium' },
  { id: 'int-53', front: 'BFS uses which structure?', back: 'Queue - FIFO for level-order traversal', category: 'queue', difficulty: 'easy' },
  { id: 'int-54', front: 'DFS uses which structure?', back: 'Stack (explicit or call stack recursion)', category: 'stack', difficulty: 'easy' },
  { id: 'int-55', front: 'Sliding window maximum?', back: 'Monotonic deque of indices', category: 'queue', difficulty: 'hard' },
  { id: 'int-56', front: 'Why deque for sliding window max?', back: 'O(1) operations on both ends', category: 'queue', difficulty: 'hard' },
  { id: 'int-57', front: 'Priority queue (heap) use cases?', back: 'K largest/smallest, merge sorted lists, scheduling', category: 'queue', difficulty: 'medium' },
  { id: 'int-58', front: 'Merge k sorted lists?', back: 'Min heap of list heads, pop smallest, add next', category: 'queue', difficulty: 'hard' },
  { id: 'int-59', front: 'Find median in stream?', back: 'Two heaps: max heap for smaller half, min heap for larger', category: 'queue', difficulty: 'hard' },
  { id: 'int-60', front: 'Task scheduler problem?', back: 'Greedy with max heap for most frequent tasks', category: 'queue', difficulty: 'hard' },

  // Trees & Graphs (40 cards)
  { id: 'int-61', front: 'Tree traversal orders?', back: 'Preorder (root-L-R), Inorder (L-root-R), Postorder (L-R-root)', category: 'trees', difficulty: 'easy' },
  { id: 'int-62', front: 'Level order traversal?', back: 'BFS with queue, process level by level', category: 'trees', difficulty: 'easy' },
  { id: 'int-63', front: 'Max depth of binary tree?', back: 'Recursive: 1 + max(left_depth, right_depth)', category: 'trees', difficulty: 'easy' },
  { id: 'int-64', front: 'Check if tree is balanced?', back: 'Height difference of subtrees ≤ 1 at every node', category: 'trees', difficulty: 'medium' },
  { id: 'int-65', front: 'Validate BST?', back: 'Check value within valid range for each node', category: 'trees', difficulty: 'medium' },
  { id: 'int-66', front: 'Inorder of BST gives?', back: 'Sorted sequence (ascending order)', category: 'trees', difficulty: 'easy' },
  { id: 'int-67', front: 'Lowest common ancestor (BST)?', back: 'First node where p and q split (one each side)', category: 'trees', difficulty: 'medium' },
  { id: 'int-68', front: 'LCA in binary tree?', back: 'Recursive: check if p/q in left or right subtree', category: 'trees', difficulty: 'medium' },
  { id: 'int-69', front: 'Serialize/deserialize binary tree?', back: 'Preorder with null markers, reconstruct recursively', category: 'trees', difficulty: 'hard' },
  { id: 'int-70', front: 'Binary tree to linked list?', back: 'Flatten in preorder, connect right pointers', category: 'trees', difficulty: 'medium' },
  { id: 'int-71', front: 'Construct tree from traversals?', back: 'Root from preorder, split inorder for subtrees', category: 'trees', difficulty: 'hard' },
  { id: 'int-72', front: 'Path sum problems approach?', back: 'DFS tracking current sum, check at leaves or nodes', category: 'trees', difficulty: 'medium' },
  { id: 'int-73', front: 'Diameter of binary tree?', back: 'Max of (left_height + right_height) at any node', category: 'trees', difficulty: 'medium' },
  { id: 'int-74', front: 'Invert binary tree?', back: 'Swap left and right children recursively', category: 'trees', difficulty: 'easy' },
  { id: 'int-75', front: 'Graph representation?', back: 'Adjacency list (dict of lists) or adjacency matrix', category: 'graphs', difficulty: 'easy' },
  { id: 'int-76', front: 'When adjacency list vs matrix?', back: 'List for sparse graphs, matrix for dense or need O(1) edge check', category: 'graphs', difficulty: 'medium' },
  { id: 'int-77', front: 'BFS graph traversal?', back: 'Queue + visited set, process neighbors level by level', category: 'graphs', difficulty: 'easy' },
  { id: 'int-78', front: 'DFS graph traversal?', back: 'Stack or recursion + visited set', category: 'graphs', difficulty: 'easy' },
  { id: 'int-79', front: 'Detect cycle in undirected graph?', back: 'DFS: if neighbor visited and not parent, cycle exists', category: 'graphs', difficulty: 'medium' },
  { id: 'int-80', front: 'Detect cycle in directed graph?', back: 'Track visiting vs visited states (3-color)', category: 'graphs', difficulty: 'medium' },
  { id: 'int-81', front: 'Topological sort?', back: 'DFS postorder reversed, or Kahn\'s with indegree', category: 'graphs', difficulty: 'hard' },
  { id: 'int-82', front: 'When to use topological sort?', back: 'Dependency resolution, course scheduling, build order', category: 'graphs', difficulty: 'medium' },
  { id: 'int-83', front: 'Number of islands?', back: 'DFS/BFS from each unvisited land, count components', category: 'graphs', difficulty: 'medium' },
  { id: 'int-84', front: 'Clone graph?', back: 'DFS/BFS with hash map: old node → cloned node', category: 'graphs', difficulty: 'medium' },
  { id: 'int-85', front: 'Word ladder (shortest path)?', back: 'BFS with single character changes', category: 'graphs', difficulty: 'hard' },
  { id: 'int-86', front: 'Pacific Atlantic water flow?', back: 'BFS/DFS from both oceans, find intersection', category: 'graphs', difficulty: 'medium' },
  { id: 'int-87', front: 'Course schedule (detect cycle)?', back: 'Build graph, check for cycle in directed graph', category: 'graphs', difficulty: 'medium' },
  { id: 'int-88', front: 'Dijkstra for shortest path?', back: 'Min heap + distances array, relax edges', category: 'graphs', difficulty: 'hard' },
  { id: 'int-89', front: 'When BFS gives shortest path?', back: 'Unweighted graph - all edges equal weight', category: 'graphs', difficulty: 'medium' },
  { id: 'int-90', front: 'Union-Find for?', back: 'Connected components, cycle detection, Kruskal\'s MST', category: 'graphs', difficulty: 'hard' },

  // Dynamic Programming (30 cards)
  { id: 'int-91', front: 'Recognize DP problems?', back: 'Optimal substructure + overlapping subproblems', category: 'dp', difficulty: 'medium' },
  { id: 'int-92', front: 'Common DP patterns?', back: 'Fibonacci, LCS, knapsack, matrix chain, intervals', category: 'dp', difficulty: 'medium' },
  { id: 'int-93', front: '1D DP examples?', back: 'Climbing stairs, house robber, coin change', category: 'dp', difficulty: 'medium' },
  { id: 'int-94', front: '2D DP examples?', back: 'LCS, edit distance, unique paths, knapsack', category: 'dp', difficulty: 'hard' },
  { id: 'int-95', front: 'DP problem solving steps?', back: '1. Define state 2. Recurrence 3. Base case 4. Order 5. Optimize', category: 'dp', difficulty: 'medium' },
  { id: 'int-96', front: 'Space optimization in DP?', back: 'Often only need previous row/state, reduce to 1D', category: 'dp', difficulty: 'hard' },
  { id: 'int-97', front: 'Unique paths in grid?', back: 'dp[i][j] = dp[i-1][j] + dp[i][j-1]', category: 'dp', difficulty: 'easy' },
  { id: 'int-98', front: 'Minimum path sum?', back: 'dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])', category: 'dp', difficulty: 'medium' },
  { id: 'int-99', front: 'Longest palindromic substring?', back: 'Expand from center or DP table of substrings', category: 'dp', difficulty: 'medium' },
  { id: 'int-100', front: 'Word break problem?', back: 'dp[i] = True if any dp[j] and s[j:i] in dict', category: 'dp', difficulty: 'medium' },
  { id: 'int-101', front: 'Decode ways ("123")?', back: 'dp[i] = dp[i-1] + dp[i-2] if valid 1 and 2 digit codes', category: 'dp', difficulty: 'medium' },
  { id: 'int-102', front: 'Stock trading problems pattern?', back: 'State: day, transactions, holding - transition based on buy/sell', category: 'dp', difficulty: 'hard' },
  { id: 'int-103', front: 'Best time to buy/sell stock I?', back: 'Track min price so far, max profit = current - min', category: 'dp', difficulty: 'easy' },
  { id: 'int-104', front: 'Best time to buy/sell stock II?', back: 'Add all positive differences (greedy)', category: 'dp', difficulty: 'easy' },
  { id: 'int-105', front: 'Maximum product subarray?', back: 'Track max and min (negative * negative = positive)', category: 'dp', difficulty: 'medium' },
  { id: 'int-106', front: 'Partition equal subset sum?', back: 'Knapsack DP: can we make sum/2?', category: 'dp', difficulty: 'medium' },
  { id: 'int-107', front: 'Target sum with +/-?', back: 'Convert to subset sum, find subsets summing to (sum+target)/2', category: 'dp', difficulty: 'hard' },
  { id: 'int-108', front: 'Jump game I?', back: 'Greedy: track farthest reachable position', category: 'dp', difficulty: 'medium' },
  { id: 'int-109', front: 'Jump game II (min jumps)?', back: 'Greedy BFS or DP', category: 'dp', difficulty: 'medium' },
  { id: 'int-110', front: 'Regular expression matching?', back: '2D DP with handling for "." and "*"', category: 'dp', difficulty: 'hard' },

  // Binary Search (20 cards)
  { id: 'int-111', front: 'Binary search template?', back: 'while lo <= hi: mid = (lo+hi)//2, adjust lo or hi', category: 'bsearch', difficulty: 'easy' },
  { id: 'int-112', front: 'Off-by-one error prevention?', back: 'Clear invariants, test edge cases', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-113', front: 'Find first/last occurrence?', back: 'Continue search even when found in appropriate direction', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-114', front: 'Search in rotated sorted array?', back: 'Check which half is sorted, search appropriate half', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-115', front: 'Find minimum in rotated array?', back: 'Compare mid with right, search unsorted half', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-116', front: 'Find peak element?', back: 'Compare mid with mid+1, go toward larger', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-117', front: 'Search in 2D matrix?', back: 'Treat as 1D array, or search row then column', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-118', front: 'Koko eating bananas?', back: 'Binary search on answer (eating speed)', category: 'bsearch', difficulty: 'medium' },
  { id: 'int-119', front: 'Binary search on answer?', back: 'When answer is bounded and can verify feasibility', category: 'bsearch', difficulty: 'hard' },
  { id: 'int-120', front: 'Median of two sorted arrays?', back: 'Binary search on partition point', category: 'bsearch', difficulty: 'hard' },

  // Bit Manipulation (20 cards)
  { id: 'int-121', front: 'Check if power of 2?', back: '`n > 0 and n & (n-1) == 0`', category: 'bits', difficulty: 'easy' },
  { id: 'int-122', front: 'Count set bits?', back: 'Loop: `count += n & 1; n >>= 1` or `bin(n).count("1")`', category: 'bits', difficulty: 'easy' },
  { id: 'int-123', front: 'Single number (others appear twice)?', back: 'XOR all numbers - duplicates cancel', category: 'bits', difficulty: 'easy' },
  { id: 'int-124', front: 'XOR properties?', back: 'a^a=0, a^0=a, commutative, associative', category: 'bits', difficulty: 'easy' },
  { id: 'int-125', front: 'Get ith bit?', back: '`(n >> i) & 1`', category: 'bits', difficulty: 'easy' },
  { id: 'int-126', front: 'Set ith bit?', back: '`n | (1 << i)`', category: 'bits', difficulty: 'easy' },
  { id: 'int-127', front: 'Clear ith bit?', back: '`n & ~(1 << i)`', category: 'bits', difficulty: 'easy' },
  { id: 'int-128', front: 'Toggle ith bit?', back: '`n ^ (1 << i)`', category: 'bits', difficulty: 'easy' },
  { id: 'int-129', front: 'Two numbers appearing once?', back: 'XOR all, find differing bit, partition by that bit', category: 'bits', difficulty: 'hard' },
  { id: 'int-130', front: 'Missing number (0 to n)?', back: 'XOR 0-n with array elements, or sum formula', category: 'bits', difficulty: 'easy' },

  // String Algorithms (20 cards)
  { id: 'int-131', front: 'Check palindrome efficiently?', back: 'Two pointers from ends or s == s[::-1]', category: 'strings', difficulty: 'easy' },
  { id: 'int-132', front: 'Valid anagram?', back: 'Sort both or compare character counts', category: 'strings', difficulty: 'easy' },
  { id: 'int-133', front: 'Longest common prefix?', back: 'Vertical scanning or sort and compare first/last', category: 'strings', difficulty: 'easy' },
  { id: 'int-134', front: 'String to integer (atoi)?', back: 'Skip whitespace, handle sign, digit by digit, check overflow', category: 'strings', difficulty: 'medium' },
  { id: 'int-135', front: 'Implement strStr()?', back: 'Naive O(nm) or KMP/Robin-Karp O(n+m)', category: 'strings', difficulty: 'medium' },
  { id: 'int-136', front: 'Reverse words in string?', back: 'Split, reverse list, join; or reverse all then each word', category: 'strings', difficulty: 'medium' },
  { id: 'int-137', front: 'Longest repeating character replacement?', back: 'Sliding window, track most frequent char count', category: 'strings', difficulty: 'hard' },
  { id: 'int-138', front: 'Minimum window substring?', back: 'Sliding window with char frequency tracking', category: 'strings', difficulty: 'hard' },
  { id: 'int-139', front: 'Edit distance applications?', back: 'Spell check, DNA sequence alignment, plagiarism', category: 'strings', difficulty: 'hard' },
  { id: 'int-140', front: 'Rabin-Karp algorithm?', back: 'Rolling hash for substring search', category: 'strings', difficulty: 'hard' },

  // Backtracking (20 cards)
  { id: 'int-141', front: 'What is backtracking?', back: 'Explore all solutions, undo (backtrack) invalid choices', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-142', front: 'Backtracking template?', back: 'Base case → for each choice: make, recurse, undo', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-143', front: 'Generate permutations?', back: 'Backtrack: swap elements, recurse, swap back', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-144', front: 'Generate combinations?', back: 'Backtrack with index to avoid duplicates', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-145', front: 'Subsets problem?', back: 'Include/exclude each element, or iterative doubling', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-146', front: 'Combination sum (reuse allowed)?', back: 'Backtrack with same index, not i+1', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-147', front: 'N-Queens problem?', back: 'Backtrack row by row, check column and diagonals', category: 'backtrack', difficulty: 'hard' },
  { id: 'int-148', front: 'Sudoku solver?', back: 'Backtrack: try 1-9 in empty cells, validate, recurse', category: 'backtrack', difficulty: 'hard' },
  { id: 'int-149', front: 'Word search in grid?', back: 'DFS/backtrack from each cell, mark visited', category: 'backtrack', difficulty: 'medium' },
  { id: 'int-150', front: 'Generate parentheses?', back: 'Backtrack: add ( if open < n, add ) if close < open', category: 'backtrack', difficulty: 'medium' },

  // Greedy (15 cards)
  { id: 'int-151', front: 'When to use greedy?', back: 'Local optimal leads to global optimal', category: 'greedy', difficulty: 'medium' },
  { id: 'int-152', front: 'Activity selection?', back: 'Sort by end time, pick non-overlapping', category: 'greedy', difficulty: 'medium' },
  { id: 'int-153', front: 'Merge intervals?', back: 'Sort by start, merge overlapping', category: 'greedy', difficulty: 'medium' },
  { id: 'int-154', front: 'Meeting rooms II (min rooms)?', back: 'Track start/end events, max concurrent', category: 'greedy', difficulty: 'medium' },
  { id: 'int-155', front: 'Gas station circuit?', back: 'Track total and current surplus, reset start on negative', category: 'greedy', difficulty: 'medium' },
  { id: 'int-156', front: 'Candy distribution?', back: 'Two passes: left to right, right to left', category: 'greedy', difficulty: 'hard' },
  { id: 'int-157', front: 'Non-overlapping intervals?', back: 'Sort by end, count non-overlapping', category: 'greedy', difficulty: 'medium' },
  { id: 'int-158', front: 'Partition labels?', back: 'Track last occurrence, extend partition', category: 'greedy', difficulty: 'medium' },
  { id: 'int-159', front: 'Queue reconstruction by height?', back: 'Sort by height desc, insert by position', category: 'greedy', difficulty: 'hard' },
  { id: 'int-160', front: 'Task scheduler?', back: 'Most frequent first, idle when no valid task', category: 'greedy', difficulty: 'hard' },

  // Math & Number Theory (20 cards)
  { id: 'int-161', front: 'Check if prime?', back: 'Check divisibility up to √n', category: 'math', difficulty: 'easy' },
  { id: 'int-162', front: 'Sieve of Eratosthenes?', back: 'Mark composites by eliminating multiples of primes', category: 'math', difficulty: 'medium' },
  { id: 'int-163', front: 'GCD algorithm?', back: 'Euclidean: gcd(a,b) = gcd(b, a%b)', category: 'math', difficulty: 'easy' },
  { id: 'int-164', front: 'LCM from GCD?', back: 'lcm(a,b) = (a*b) // gcd(a,b)', category: 'math', difficulty: 'easy' },
  { id: 'int-165', front: 'Power of 3?', back: 'Loop divide by 3, or log3(n) is integer', category: 'math', difficulty: 'easy' },
  { id: 'int-166', front: 'Integer reverse?', back: 'Pop digits with %10, build with *10, check overflow', category: 'math', difficulty: 'easy' },
  { id: 'int-167', front: 'Palindrome number?', back: 'Reverse and compare, or compare half digits', category: 'math', difficulty: 'easy' },
  { id: 'int-168', front: 'Factorial trailing zeros?', back: 'Count factors of 5: n/5 + n/25 + n/125...', category: 'math', difficulty: 'medium' },
  { id: 'int-169', front: 'Happy number?', back: 'Sum of squared digits cycle detection (fast/slow)', category: 'math', difficulty: 'easy' },
  { id: 'int-170', front: 'Excel column number?', back: 'Base 26 conversion: A=1, Z=26', category: 'math', difficulty: 'easy' },
  { id: 'int-171', front: 'Fizz Buzz?', back: 'Check %15 first, then %3, then %5, else number', category: 'math', difficulty: 'easy' },
  { id: 'int-172', front: 'Count primes up to n?', back: 'Sieve of Eratosthenes O(n log log n)', category: 'math', difficulty: 'medium' },
  { id: 'int-173', front: 'Ugly numbers (2,3,5 factors only)?', back: 'DP with three pointers for multiples of 2,3,5', category: 'math', difficulty: 'medium' },
  { id: 'int-174', front: 'Power(x, n)?', back: 'Fast exponentiation: x^n = x^(n/2) * x^(n/2)', category: 'math', difficulty: 'medium' },
  { id: 'int-175', front: 'Square root integer?', back: 'Binary search for largest x where x*x <= n', category: 'math', difficulty: 'easy' },

  // Linked List (15 cards)
  { id: 'int-176', front: 'Reverse linked list?', back: 'Track prev, curr, next. Redirect pointers.', category: 'linkedlist', difficulty: 'easy' },
  { id: 'int-177', front: 'Merge two sorted lists?', back: 'Two pointers, compare heads, build result', category: 'linkedlist', difficulty: 'easy' },
  { id: 'int-178', front: 'Remove nth from end?', back: 'Two pointers n nodes apart', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-179', front: 'Add two numbers (lists)?', back: 'Traverse both, track carry, handle different lengths', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-180', front: 'Reorder list (L0→Ln→L1→Ln-1)?', back: 'Find middle, reverse second half, merge', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-181', front: 'Palindrome linked list?', back: 'Find middle, reverse second half, compare', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-182', front: 'Intersection of two lists?', back: 'Align by length or cycle (a then b, b then a)', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-183', front: 'Copy list with random pointer?', back: 'Hash map old→new or interleave copies', category: 'linkedlist', difficulty: 'medium' },
  { id: 'int-184', front: 'Sort linked list?', back: 'Merge sort: find middle, split, sort, merge', category: 'linkedlist', difficulty: 'hard' },
  { id: 'int-185', front: 'Rotate list by k?', back: 'Find length, connect to cycle, break at right point', category: 'linkedlist', difficulty: 'medium' },

  // Design & System (15 cards)
  { id: 'int-186', front: 'LRU Cache design?', back: 'Hash map + doubly linked list for O(1) access/update', category: 'design', difficulty: 'hard' },
  { id: 'int-187', front: 'Min Stack design?', back: 'Two stacks or store (value, min) pairs', category: 'design', difficulty: 'medium' },
  { id: 'int-188', front: 'Design Twitter?', back: 'User map, follow set, tweet list, merge k feeds', category: 'design', difficulty: 'hard' },
  { id: 'int-189', front: 'Implement Trie?', back: 'Node with children dict and isEnd flag', category: 'design', difficulty: 'medium' },
  { id: 'int-190', front: 'Trie search vs prefix?', back: 'Search checks isEnd, prefix just checks path exists', category: 'design', difficulty: 'medium' },
  { id: 'int-191', front: 'Word Dictionary with wildcards?', back: 'Trie with DFS for "." wildcards', category: 'design', difficulty: 'hard' },
  { id: 'int-192', front: 'Design HashMap?', back: 'Array of buckets, hash function, handle collisions', category: 'design', difficulty: 'medium' },
  { id: 'int-193', front: 'Collision handling strategies?', back: 'Chaining (linked list) or open addressing (probing)', category: 'design', difficulty: 'medium' },
  { id: 'int-194', front: 'Design File System?', back: 'Trie-like structure for path components', category: 'design', difficulty: 'medium' },
  { id: 'int-195', front: 'Iterator pattern?', back: '__iter__ returns self, __next__ returns value/raises StopIteration', category: 'design', difficulty: 'medium' },
  { id: 'int-196', front: 'Flatten nested list iterator?', back: 'Stack with reverse push of nested elements', category: 'design', difficulty: 'medium' },
  { id: 'int-197', front: 'Binary Search Tree Iterator?', back: 'Stack with leftmost path, pop and push right subtree', category: 'design', difficulty: 'medium' },
  { id: 'int-198', front: 'Serialize/deserialize patterns?', back: 'Preorder with nulls, BFS level order, parentheses', category: 'design', difficulty: 'hard' },
  { id: 'int-199', front: 'Time-based key-value store?', back: 'Dict of lists, binary search for timestamp', category: 'design', difficulty: 'medium' },
  { id: 'int-200', front: 'Random pick with weight?', back: 'Prefix sum + binary search for target', category: 'design', difficulty: 'medium' }
];

export default interviewFlashcards;
