Introduction to Python
Understanding what Python is and why it's popular
Python is a high-level, interpreted programming language known for its simplicity and readability. Created by Guido van Rossum in 1991, Python emphasizes code readability and allows programmers to express concepts in fewer lines of code.
Python is interpreted - no compilation needed
Dynamically typed - no need to declare variable types
Cross-platform - runs on Windows, Mac, Linux
Huge standard library and ecosystem
Used in web development, data science, AI, automation, and more
Web Development
Build websites and web applications using Django, Flask, FastAPI
Instagram, Spotify, and Pinterest use Python
Data Science & AI
Analyze data, create visualizations, build machine learning models
Pandas, NumPy, TensorFlow, PyTorch libraries
Automation & Scripting
Automate repetitive tasks, system administration
File management, web scraping, testing automation
Game Development
Create games using Pygame library
Simple 2D games and prototypes
Follow PEP 8 style guide for readable code
Use meaningful variable and function names
Write comments to explain complex logic
Use virtual environments for project dependencies
Test your code regularly
Don't use single letter variable names (except in loops)
Don't ignore errors and exceptions
Don't mix tabs and spaces for indentation
Don't write functions that do too many things
Don't hardcode values that might change
Use 4 spaces for indentation (not tabs)
Keep lines under 79 characters when possible
Use docstrings to document functions and classes
Import modules at the top of the file
Use version control (Git) for your projects
Your First Python Program
The print() function displays output. Use # for single-line comments and triple quotes for multi-line strings.
Variables and Data Types
Learn to store and manipulate different types of data
Variables are containers for storing data values. Python has various built-in data types including numbers, strings, booleans, lists, tuples, dictionaries, and sets. Understanding data types is fundamental to writing effective Python code.
Variables don't need explicit declaration
Variable names are case-sensitive
Python determines type automatically (dynamic typing)
You can change a variable's type after it's set
Use type() function to check a variable's type
Storing User Information
Store names, ages, email addresses
name = "John", age = 25, email = "john@example.com"
Mathematical Calculations
Perform arithmetic operations
price = 100, tax = 0.15, total = price * (1 + tax)
Boolean Logic
Control program flow with true/false values
is_logged_in = True, has_permission = False
Text Processing
Manipulate strings for various applications
Processing user input, formatting output
Use descriptive variable names (user_age instead of x)
Follow naming conventions (lowercase with underscores)
Initialize variables before using them
Use constants in UPPERCASE (MAX_SIZE = 100)
Choose appropriate data types for your data
Don't use Python keywords as variable names (if, for, while)
Don't start variable names with numbers
Don't use spaces in variable names
Don't reuse variable names for different purposes
Don't ignore type compatibility in operations
Use meaningful names that describe the data
Keep variable scope as small as possible
Group related variables together
Use type hints for better code documentation
Validate input data before assigning to variables
Basic Data Types
Python has four primitive data types: int, float, str, and bool. The type() function shows the type of any variable.
Type Conversion
Use int(), float(), str(), and bool() functions to convert between types. Some conversions may lose precision or fail.
Multiple Assignment
Python allows elegant multiple assignments and swapping without temporary variables.
Operators
Perform operations and comparisons
Operators are symbols that perform operations on variables and values. Python supports arithmetic, comparison, logical, assignment, and other operators. Understanding operators is essential for performing calculations and making decisions in your code.
Arithmetic operators: +, -, *, /, //, %, **
Comparison operators: ==, !=, >, <, >=, <=
Logical operators: and, or, not
Assignment operators: =, +=, -=, *=, /=
Operator precedence follows mathematical rules
Mathematical Calculations
Calculate totals, averages, percentages
total = price * quantity; average = sum / count
Conditional Logic
Make decisions based on conditions
if age >= 18 and has_id: grant_access()
String Operations
Concatenate and repeat strings
full_name = first + " " + last; line = "=" * 50
Membership Testing
Check if value exists in collection
if "admin" in user_roles: show_admin_panel()
Use parentheses to clarify complex expressions
Use // for integer division when you need whole numbers
Use ** for exponentiation instead of pow()
Chain comparisons (x < y < z) for readability
Use += and similar operators for concise updates
Don't compare floats with == (use math.isclose())
Don't use = when you mean == in conditions
Don't chain assignments with operators (x = y += 1)
Don't forget operator precedence (* before +)
Don't use "is" for value comparison (use ==)
Use meaningful spacing around operators for readability
Break complex expressions into smaller parts
Use comparison chaining when appropriate
Prefer "is None" over "== None" for None checks
Use descriptive variable names in boolean expressions
Arithmetic Operators
Python follows standard mathematical operator precedence. Use parentheses to control order of operations.
Comparison Operators
Comparison operators compare values and return boolean results. Python allows chaining comparisons elegantly.
Logical Operators
Logical operators combine boolean expressions. Python uses short-circuit evaluation for efficiency.
Assignment and Identity Operators
Assignment operators provide shortcuts. Use "is" for identity (same object), "==" for equality (same value).
Membership and Other Operators
Membership operators check for presence in sequences. The ternary operator provides concise conditional assignment.
Installing Python
Learn how to install Python on different operating systems
Python installation is the first step in your programming journey. Python is available for Windows, macOS, and Linux. Understanding proper installation ensures you have the right environment for development.
Python can be downloaded from python.org
Windows: Use the official installer with "Add to PATH" option
macOS: Can use Homebrew or official installer
Linux: Usually pre-installed, can use package managers
Verify installation using python --version command
Windows Installation
Install Python on Windows systems
Download from python.org, run installer, check "Add Python to PATH"
macOS Installation
Install using Homebrew or official installer
brew install python3 or download from python.org
Development Environment
Set up IDE or code editor
VS Code, PyCharm, Jupyter Notebook
Virtual Environments
Isolate project dependencies
python -m venv myenv
Always add Python to system PATH during installation
Verify installation immediately after installing
Install pip (Python package manager) if not included
Consider using virtual environments for projects
Keep Python updated to latest stable version
Don't install multiple Python versions without version managers
Don't skip adding to PATH on Windows
Don't ignore security warnings during installation
Don't install packages globally without virtual environments
Don't use Python 2.x for new projects (it's deprecated)
Use version managers like pyenv for multiple Python versions
Create virtual environments for each project
Document Python version requirements in README
Use requirements.txt for package dependencies
Regularly update pip: python -m pip install --upgrade pip
Verify Python Installation
Use command line to verify Python and pip are correctly installed
Create Virtual Environment
Virtual environments keep project dependencies isolated and manageable
Python Execution Modes
Interactive vs Script mode execution
Python can be executed in two primary modes: Interactive Mode for testing snippets and quick experimentation, and Script Mode for running complete programs. Understanding both modes helps you work efficiently.
Interactive mode: REPL (Read-Eval-Print-Loop) for immediate feedback
Script mode: Execute complete Python files (.py)
Interactive mode is great for learning and testing
Script mode is used for production code
Both modes execute Python code identically
Interactive Mode - Testing
Quick testing of Python expressions
>>> 2 + 2 [Enter] returns 4 immediately
Interactive Mode - Learning
Explore Python features and libraries
Try different functions and see results instantly
Script Mode - Applications
Create complete programs and applications
web apps, data analysis scripts, automation tools
Script Mode - Production
Deploy code to servers and production environments
Run scheduled tasks, web servers, batch processing
Use interactive mode for quick testing and learning
Use script mode for any code you want to save
Add .py extension to all Python script files
Include shebang line in scripts for Unix systems
Make scripts executable with proper permissions
Don't write long programs in interactive mode
Don't forget to save your work when exiting interactive mode
Don't use interactive mode for production code
Don't run untrusted scripts without reviewing
Don't forget error handling in scripts
Use interactive mode for experimentation
Write scripts for reusable code
Add comments and docstrings in scripts
Use if __name__ == "__main__": for script entry points
Test scripts thoroughly before deployment
Interactive Mode Usage
Interactive mode provides immediate feedback, great for testing
Script Mode - Creating a Python File
Script mode allows you to write complete programs and save them for reuse
Script with Command Line Arguments
Scripts can accept command-line arguments for dynamic behavior
Python Tokens - Building Blocks
Understanding the smallest units of Python programs
Tokens are the smallest individual units of a Python program - the building blocks of code. When Python reads your code, it breaks it into tokens: keywords, identifiers, literals, operators, and delimiters. Understanding tokens is fundamental to writing correct Python code.
Tokens are the smallest lexical units in Python
Five types: Keywords, Identifiers, Literals, Operators, Delimiters
Python interpreter breaks code into tokens during execution
Each token has a specific purpose and meaning
Proper token usage ensures syntactically correct code
Keywords - Reserved Words
Reserved words with special meaning (if, else, for, while, def, class, etc.)
if x > 10: # "if" is a keyword token
Identifiers - Names
Names given to variables, functions, classes
student_name = "Alice" # student_name is identifier
Literals - Values
Fixed values like numbers, strings, booleans
42, "hello", True, 3.14 are all literals
Operators - Actions
Symbols that perform operations (+, -, *, /, ==, !=, etc.)
x = 5 + 3 # = and + are operator tokens
Delimiters - Structure
Punctuation that organizes code ((), [], {}, :, ,)
my_list = [1, 2, 3] # [] and , are delimiters
Use descriptive identifiers that explain purpose
Follow Python naming conventions (PEP 8)
Use appropriate literals for data types
Understand operator precedence
Use delimiters correctly for grouping
Don't use keywords as identifiers
Don't create confusing identifier names
Don't mix token types incorrectly
Don't ignore Python syntax rules
Don't use reserved words for variable names
Use snake_case for variables and functions
Use CamelCase for class names
Make identifiers meaningful and readable
Group related tokens with proper delimiters
Understand token roles in your code
Understanding All Token Types
This example shows all five token types working together in a complete program
Python Keywords (Reserved Words)
Keywords are reserved and cannot be used as variable names
Valid vs Invalid Identifiers
Identifiers must follow naming rules: start with letter/underscore, no keywords
Control Flow - if/else Statements
Making decisions in your code
Control flow statements allow your program to make decisions and execute different code based on conditions. The if/elif/else statements are fundamental for creating logic in programs - from simple checks to complex decision trees.
if statement executes code when condition is True
elif (else if) checks additional conditions
else executes when all conditions are False
Conditions use comparison operators (==, !=, <, >, <=, >=)
Indentation defines code blocks (4 spaces)
User Input Validation
Check if user input meets requirements
Validate age, email format, password strength
Business Logic
Implement business rules and decisions
Calculate discounts, determine eligibility, route requests
Error Handling
Check for errors before processing
Verify file exists, check network connection, validate data
Game Logic
Control game flow based on player actions
Check win/lose conditions, validate moves, update scores
Use clear, readable conditions
Handle all possible cases
Use elif instead of multiple if when appropriate
Keep condition expressions simple
Test edge cases thoroughly
Don't forget the colon (:) after conditions
Don't mix tabs and spaces for indentation
Don't create overly complex nested conditions
Don't forget to handle the else case
Don't use assignment (=) instead of comparison (==)
Use 4 spaces for indentation consistently
Order conditions from most to least likely
Use boolean variables for complex conditions
Consider using match/case for many conditions (Python 3.10+)
Write self-documenting condition names
Basic if/elif/else Structure
elif allows checking multiple conditions in order, stops at first True
Nested Conditions and Logical Operators
Use logical operators (and, or, not) for complex conditions. Early returns reduce nesting.
Real-World Example: E-commerce Discount
Real-world example combining multiple conditions to calculate discounts
Loops - for and while
Repeating actions efficiently
Loops allow you to repeat code multiple times without writing it over and over. Python provides two main loop types: "for" loops for iterating over sequences, and "while" loops for repeating until a condition changes. Mastering loops is essential for processing data and automating tasks.
for loops iterate over sequences (lists, strings, ranges)
while loops repeat while condition is True
break exits the loop immediately
continue skips to next iteration
range() generates number sequences for loops
Loops can be nested for multi-dimensional processing
Data Processing
Process each item in a dataset
Analyze list of sales, calculate statistics, filter data
User Interaction
Keep asking for input until valid
Menu systems, input validation, game loops
File Operations
Read file line by line
Process log files, parse CSV data, analyze text
Automation
Repeat tasks automatically
Send emails, download files, update databases
Use for loops when you know the number of iterations
Use while loops when iterations depend on a condition
Always ensure while loops can terminate
Use break to exit loops when needed
Use meaningful variable names in loops
Don't create infinite loops accidentally
Don't modify the sequence you're iterating over
Don't use loops when built-in functions exist
Don't forget to update while loop conditions
Don't nest too many loops (reduces readability)
Use enumerate() to get index and value together
Use list comprehensions for simple transformations
Consider using zip() for parallel iteration
Use else clause with loops for no-break scenarios
Profile nested loops for performance
for Loop - Iterating Over Collections
for loops are perfect for iterating over known sequences
while Loop - Condition-Based Repetition
while loops continue until condition becomes False
Loop Control - break, continue, else
break exits loop, continue skips iteration, else runs if no break occurred
Real-World: Data Analysis Loop
Complete example combining loops, conditionals, and data processing
Python Tokens and Keywords
Understanding the building blocks of Python code
Tokens are the smallest units of a Python program. They include keywords, identifiers, literals, operators, and delimiters. Keywords are reserved words with special meaning that cannot be used as variable names.
Python has 35 reserved keywords (as of Python 3.11)
Keywords are case-sensitive (True, False, None)
Cannot use keywords as variable/function names
Some keywords are soft keywords (match, case in Python 3.10+)
Use keyword module to list all keywords
Control Flow Keywords
if, elif, else, for, while, break, continue, pass
Control program execution flow
Function and Class Keywords
def, class, return, yield, lambda
Define functions, classes, and generators
Logic Keywords
and, or, not, in, is
Boolean operations and membership testing
Exception Keywords
try, except, finally, raise, assert
Error handling and debugging
Use keywords correctly according to Python syntax
Learn the purpose of each keyword
Use meaningful identifiers instead of keywords
Check if a word is a keyword using keyword.iskeyword()
Follow PEP 8 naming conventions for identifiers
Don't use keywords as variable names
Don't misspell keywords (e.g., Def instead of def)
Don't use reserved words from other languages
Don't create identifiers that look like keywords
Don't ignore case sensitivity in keywords
Memorize commonly used keywords
Use IDE with syntax highlighting
Understand keyword context and usage
Keep updated with new keywords in Python versions
Use descriptive names for identifiers
All Python Keywords
Python provides the keyword module to work with keywords programmatically
Keywords in Action
Different categories of keywords serve different purposes in Python programming
Common Keyword Mistakes
Keywords are case-sensitive and cannot be used as variable names
Identifiers and Naming Rules
Learn how to name variables, functions, and classes properly
Identifiers are names given to variables, functions, classes, modules, and other objects. Python has specific rules for valid identifiers and conventions for readable, maintainable code.
Identifiers can contain letters, digits, and underscores
Must start with a letter (a-z, A-Z) or underscore (_)
Cannot start with a digit
Case-sensitive (Name and name are different)
Cannot be a Python keyword
Variable Names
Store data values with descriptive names
user_age, total_price, is_valid
Function Names
Name functions describing what they do
calculate_total(), send_email(), validate_input()
Class Names
Name classes using CapWords convention
UserAccount, ShoppingCart, DatabaseManager
Constants
Use UPPERCASE for constants
MAX_SIZE, PI, DEFAULT_TIMEOUT
Use descriptive and meaningful names
Follow snake_case for variables and functions
Use CapWords (PascalCase) for class names
Use UPPERCASE for constants
Keep names concise but clear
Don't use single letters except in loops (i, j, k)
Don't start names with numbers
Don't use special characters (@, #, $, etc.)
Don't use Python keywords as names
Don't create ambiguous or cryptic names
Use verb_noun for function names: get_user(), calculate_total()
Use is/has prefix for boolean variables: is_active, has_permission
Avoid abbreviations unless widely understood
Be consistent with naming conventions across project
Use single underscore prefix for internal/private names
Valid vs Invalid Identifiers
Follow Python naming rules to avoid syntax errors
Naming Conventions (PEP 8)
Following PEP 8 conventions makes code readable and maintainable
Descriptive Names
Descriptive names make code self-documenting and easier to understand
Python Literals
Understanding different types of literal values
Literals are fixed values that appear directly in code. Python supports numeric literals (integers, floats, complex), string literals, boolean literals (True/False), and special literal None. Understanding literals is fundamental to working with data.
Numeric literals: integers, floats, complex numbers
String literals: single, double, triple quotes
Boolean literals: True and False (capitalized)
None literal: represents absence of value
Collection literals: lists [], tuples (), dicts {}, sets {}
Numeric Calculations
Direct number values in expressions
total = 100 + 50 * 1.5
String Messages
Fixed text values in programs
greeting = "Welcome to Python!"
Boolean Flags
True/False conditions
is_active = True, debug_mode = False
Default Values
None for uninitialized variables
user_input = None
Use appropriate literal types for your data
Use triple quotes for multi-line strings
Use raw strings (r"") for regular expressions
Use underscores in large numbers for readability
Use None for missing/undefined values
Don't use quotes around numeric literals
Don't confuse 0/1 with False/True
Don't use empty strings for None
Don't ignore decimal precision in float literals
Don't mix number bases without clarity
Use f-strings for string formatting (Python 3.6+)
Use scientific notation for very large/small numbers
Use explicit type conversion when needed
Document complex number usage
Use constants for repeated literal values
Numeric Literals
Python supports various numeric literal formats for different bases and types
String Literals
Python offers flexible string literal syntax for different use cases
Boolean and None Literals
Boolean and None literals are fundamental for control flow and representing absence of values
Collection Literals
Collection literals provide convenient syntax for creating data structures
Comments and Documentation
Writing clear comments and docstrings
Comments are annotations in code that Python ignores during execution. They explain what code does, why decisions were made, and how to use functions/classes. Good comments make code maintainable and collaborative.
Single-line comments start with #
Multi-line comments use triple quotes (""" or ''')
Docstrings document modules, classes, functions
Comments explain WHY, not WHAT (code shows what)
Keep comments up-to-date with code changes
Code Explanation
Clarify complex logic or algorithms
# Using binary search for O(log n) performance
Function Documentation
Describe function purpose, parameters, returns
Docstrings with parameter descriptions
TODO Markers
Mark incomplete or planned features
# TODO: Add error handling for network failures
Debugging
Temporarily disable code
# print(debug_info)  # Commented out for production
Write clear, concise comments
Use docstrings for all public functions/classes
Explain WHY code exists, not just what it does
Keep comments up-to-date
Use TODO, FIXME, NOTE markers for special comments
Don't state the obvious (# increment x by 1)
Don't write novels - be concise
Don't leave outdated comments
Don't comment out large blocks permanently
Don't use comments to hide bad code names
Self-documenting code reduces need for comments
Use docstrings that tools can extract
Follow PEP 257 for docstring conventions
Explain complex algorithms with references
Use inline comments sparingly
Single-Line Comments
Single-line comments start with # and extend to end of line
Docstrings - Function Documentation
Docstrings are the first statement in a function/class. Triple quotes allow multi-line text
Class and Module Docstrings
Module and class docstrings provide high-level documentation. Use consistent format (Google, NumPy, or Sphinx style)
Commenting Best Practices
Good comments explain complex logic, assumptions, and reasoning. Code should be self-explanatory where possible
Getting User Input
Learn how to accept and process user input in Python
The input() function allows Python programs to interact with users by accepting text input from the keyboard. Understanding how to get, validate, and convert user input is essential for creating interactive programs.
input() function reads user input as a string
Always returns a string, even if user types numbers
Use type conversion to get numbers from input
Can provide a prompt message to guide users
Input waits for user to press Enter
Interactive Programs
Create programs that respond to user choices
Calculators, games, menus, configuration tools
Data Collection
Gather information from users
Registration forms, surveys, questionnaires
Configuration
Let users customize program behavior
Settings, preferences, parameters
Testing
Manually test program logic
Input test data, verify outputs
Always validate user input
Provide clear prompts explaining what to enter
Handle invalid input gracefully
Convert input to appropriate type (int, float, etc.)
Use try-except for type conversion errors
Don't assume input is valid
Don't forget input() returns strings
Don't use vague prompts like "Enter:"
Don't crash on invalid input
Don't ask for input multiple times unnecessarily
Validate input immediately after receiving it
Provide examples in prompts: "Enter age (e.g., 25): "
Use loops to re-prompt on invalid input
Strip whitespace from input: input().strip()
Consider default values for optional input
Basic Input
input() displays a prompt and waits for user to type and press Enter
Converting Input Types
Use int(), float(), bool() to convert string input to other types
Input Validation
Always validate input to prevent errors and ensure data quality
Real-World Example: Simple Calculator
Robust input handling makes programs user-friendly and error-resistant
Displaying Output
Master the print() function and output formatting
The print() function displays output to the console. Python offers multiple ways to format output, from simple concatenation to advanced f-strings. Understanding output formatting is crucial for creating readable, professional programs.
print() displays text and values to the console
Can print multiple values separated by spaces
f-strings (f"") provide easy string formatting
format() method for complex formatting
Can control separator and ending characters
Debugging
Display variable values during development
print(f"x={x}, y={y}")
User Feedback
Show results, messages, and status
Success messages, error notifications, progress updates
Reports
Generate formatted reports and tables
Sales reports, data summaries, invoices
Logging
Record program activities
Application logs, audit trails
Use f-strings for readable formatting (Python 3.6+)
Provide clear, informative messages
Use proper spacing and alignment
End with newline for readability
Format numbers appropriately (decimals, currency, etc.)
Don't print excessive debug output in production
Don't ignore formatting for user-facing output
Don't use print() for logging in large applications
Don't forget to remove debug prints
Don't assume terminal width
Use f-strings for modern, readable formatting
Align columns for tabular data
Use thousands separators for large numbers
Include units in output (e.g., "25 kg", "100 USD")
Consider using logging module instead of print for apps
Basic Print Statements
print() is versatile - can print one or more values with custom separators and endings
String Formatting with f-strings
f-strings provide the most readable and powerful way to format strings in modern Python
Other Formatting Methods
Multiple formatting methods exist, but f-strings are recommended for clarity
Real-World Example: Receipt Formatter
Proper formatting creates professional-looking output for reports and receipts